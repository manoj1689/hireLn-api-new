# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE googleId = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'googleId': 'ggciceaie',
                'name': 'bbehjachib',
                'email': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'googleId': 'dgiiaaijj',
                    'name': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'googleId': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'email': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the name field
        users = await User.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the email field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the avatar field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'avatar': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'googleId': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'email': 'biabhbdai',
                },
                'update': {
                    'googleId': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'email': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'role': enums.UserRole.ADMIN
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'fcm_token': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'accountType': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by subscriptionActive values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['subscriptionActive'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ActivityActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Activity]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Activity.prisma().query_raw(
            'SELECT * FROM Activity WHERE id = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Activity
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Activity.prisma().query_first(
            'SELECT * FROM Activity WHERE type = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ActivityCreateInput,
        include: Optional[types.ActivityInclude] = None
    ) -> _PrismaModelT:
        """Create a new Activity record.

        Parameters
        ----------
        data
            Activity record data
        include
            Specifies which relations should be loaded on the returned Activity model

        Returns
        -------
        prisma.models.Activity
            The created Activity record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Activity record from just the required fields
        activity = await Activity.prisma().create(
            data={
                # data to create a Activity record
                'type': 'bgehebiafc',
                'title': 'bghffegacj',
                'description': 'bhghchehcc',
                'userId': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ActivityCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Activity records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Activity record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Activity.prisma().create_many(
            data=[
                {
                    # data to create a Activity record
                    'type': 'bdedcabahc',
                    'title': 'ghfhiafcb',
                    'description': 'heejgedji',
                    'userId': 'bjgjgibgbf',
                },
                {
                    # data to create a Activity record
                    'type': 'bbbgbhfjge',
                    'title': 'igbehcbab',
                    'description': 'bdadaadhag',
                    'userId': 'bgiggdidbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ActivityWhereUniqueInput,
        include: Optional[types.ActivityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Activity record.

        Parameters
        ----------
        where
            Activity filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Activity model

        Returns
        -------
        prisma.models.Activity
            The deleted Activity record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        activity = await Activity.prisma().delete(
            where={
                'id': 'caaaedabfc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ActivityWhereUniqueInput,
        include: Optional[types.ActivityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Activity record.

        Parameters
        ----------
        where
            Activity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Activity model

        Returns
        -------
        prisma.models.Activity
            The found Activity record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        activity = await Activity.prisma().find_unique(
            where={
                'id': 'bigibebcib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ActivityWhereUniqueInput,
        include: Optional[types.ActivityInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Activity record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Activity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Activity model

        Returns
        -------
        prisma.models.Activity
            The found Activity record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        activity = await Activity.prisma().find_unique_or_raise(
            where={
                'id': 'bigaiehgcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActivityWhereInput] = None,
        cursor: Optional[types.ActivityWhereUniqueInput] = None,
        include: Optional[types.ActivityInclude] = None,
        order: Optional[Union[types.ActivityOrderByInput, List[types.ActivityOrderByInput]]] = None,
        distinct: Optional[List[types.ActivityScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Activity records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Activity records returned
        skip
            Ignore the first N results
        where
            Activity filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Activity model
        order
            Order the returned Activity records by any field
        distinct
            Filter Activity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Activity]
            The list of all Activity records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Activity records
        activitys = await Activity.prisma().find_many(take=10)

        # find the first 5 Activity records ordered by the title field
        activitys = await Activity.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ActivityWhereInput] = None,
        cursor: Optional[types.ActivityWhereUniqueInput] = None,
        include: Optional[types.ActivityInclude] = None,
        order: Optional[Union[types.ActivityOrderByInput, List[types.ActivityOrderByInput]]] = None,
        distinct: Optional[List[types.ActivityScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Activity record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Activity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Activity model
        order
            Order the returned Activity records by any field
        distinct
            Filter Activity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Activity
            The first Activity record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Activity record ordered by the description field
        activity = await Activity.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ActivityWhereInput] = None,
        cursor: Optional[types.ActivityWhereUniqueInput] = None,
        include: Optional[types.ActivityInclude] = None,
        order: Optional[Union[types.ActivityOrderByInput, List[types.ActivityOrderByInput]]] = None,
        distinct: Optional[List[types.ActivityScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Activity record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Activity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Activity model
        order
            Order the returned Activity records by any field
        distinct
            Filter Activity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Activity
            The first Activity record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Activity record ordered by the userId field
        activity = await Activity.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ActivityUpdateInput,
        where: types.ActivityWhereUniqueInput,
        include: Optional[types.ActivityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Activity record.

        Parameters
        ----------
        data
            Activity record data specifying what to update
        where
            Activity filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Activity model

        Returns
        -------
        prisma.models.Activity
            The updated Activity record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        activity = await Activity.prisma().update(
            where={
                'id': 'beeifcbebf',
            },
            data={
                # data to update the Activity record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ActivityWhereUniqueInput,
        data: types.ActivityUpsertInput,
        include: Optional[types.ActivityInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Activity filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Activity model

        Returns
        -------
        prisma.models.Activity
            The created or updated Activity record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        activity = await Activity.prisma().upsert(
            where={
                'id': 'bgcigfahea',
            },
            data={
                'create': {
                    'id': 'bgcigfahea',
                    'type': 'bbbgbhfjge',
                    'title': 'igbehcbab',
                    'description': 'bdadaadhag',
                    'userId': 'bgiggdidbf',
                },
                'update': {
                    'type': 'bbbgbhfjge',
                    'title': 'igbehcbab',
                    'description': 'bdadaadhag',
                    'userId': 'bgiggdidbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ActivityUpdateManyMutationInput,
        where: types.ActivityWhereInput,
    ) -> int:
        """Update multiple Activity records

        Parameters
        ----------
        data
            Activity data to update the selected Activity records to
        where
            Filter to select the Activity records to update

        Returns
        -------
        int
            The total number of Activity records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Activity records
        total = await Activity.prisma().update_many(
            data={
                'entityId': 'bcejgaggif'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActivityWhereInput] = None,
        cursor: Optional[types.ActivityWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Activity records present in the database

        Parameters
        ----------
        select
            Select the Activity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Activity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ActivityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Activity.prisma().count()

        # results: prisma.types.ActivityCountAggregateOutput
        results = await Activity.prisma().count(
            select={
                '_all': True,
                'entityType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ActivityCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActivityWhereInput] = None,
        cursor: Optional[types.ActivityWhereUniqueInput] = None,
    ) -> types.ActivityCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ActivityCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActivityWhereInput] = None,
        cursor: Optional[types.ActivityWhereUniqueInput] = None,
    ) -> Union[int, types.ActivityCountAggregateOutput]:
        """Count the number of Activity records present in the database

        Parameters
        ----------
        select
            Select the Activity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Activity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ActivityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Activity.prisma().count()

        # results: prisma.types.ActivityCountAggregateOutput
        results = await Activity.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ActivityCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ActivityWhereInput] = None
    ) -> int:
        """Delete multiple Activity records.

        Parameters
        ----------
        where
            Optional Activity filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Activity records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Activity records
        total = await Activity.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ActivityScalarFieldKeys'],
        *,
        where: Optional['types.ActivityWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ActivityAvgAggregateInput'] = None,
        sum: Optional['types.ActivitySumAggregateInput'] = None,
        min: Optional['types.ActivityMinAggregateInput'] = None,
        max: Optional['types.ActivityMaxAggregateInput'] = None,
        having: Optional['types.ActivityScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ActivityCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ActivityScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ActivityScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ActivityGroupByOutput']:
        """Group Activity records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Activity fields to group records by
        where
            Activity filter to select records
        take
            Limit the maximum number of Activity records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ActivityGroupByOutput]
            A list of dictionaries representing the Activity record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Activity records by createdAt values
        # and count how many records are in each group
        results = await Activity.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSettingsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSettings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSettings.prisma().query_raw(
            'SELECT * FROM UserSettings WHERE id = $1',
            'idfjadbcc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSettings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSettings.prisma().query_first(
            'SELECT * FROM UserSettings WHERE userId = $1',
            'hgdhbjhhj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSettingsCreateInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSettings record.

        Parameters
        ----------
        data
            UserSettings record data
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The created UserSettings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSettings record from just the required fields
        usersettings = await UserSettings.prisma().create(
            data={
                # data to create a UserSettings record
                'userId': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSettingsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSettings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSettings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSettings.prisma().create_many(
            data=[
                {
                    # data to create a UserSettings record
                    'userId': 'bhhfibbigf',
                },
                {
                    # data to create a UserSettings record
                    'userId': 'ijdbeffgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSettings record.

        Parameters
        ----------
        where
            UserSettings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The deleted UserSettings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().delete(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSettings record.

        Parameters
        ----------
        where
            UserSettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The found UserSettings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().find_unique(
            where={
                'id': 'cbachdgfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSettings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The found UserSettings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().find_unique_or_raise(
            where={
                'id': 'chbfcacbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
        include: Optional[types.UserSettingsInclude] = None,
        order: Optional[Union[types.UserSettingsOrderByInput, List[types.UserSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSettingsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSettings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSettings records returned
        skip
            Ignore the first N results
        where
            UserSettings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSettings model
        order
            Order the returned UserSettings records by any field
        distinct
            Filter UserSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSettings]
            The list of all UserSettings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSettings records
        usersettings = await UserSettings.prisma().find_many(take=10)

        # find the first 5 UserSettings records ordered by the language field
        usersettings = await UserSettings.prisma().find_many(
            take=5,
            order={
                'language': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
        include: Optional[types.UserSettingsInclude] = None,
        order: Optional[Union[types.UserSettingsOrderByInput, List[types.UserSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSettingsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSettings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSettings model
        order
            Order the returned UserSettings records by any field
        distinct
            Filter UserSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSettings
            The first UserSettings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSettings record ordered by the timezone field
        usersettings = await UserSettings.prisma().find_first(
            skip=1,
            order={
                'timezone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
        include: Optional[types.UserSettingsInclude] = None,
        order: Optional[Union[types.UserSettingsOrderByInput, List[types.UserSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSettingsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSettings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSettings model
        order
            Order the returned UserSettings records by any field
        distinct
            Filter UserSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSettings
            The first UserSettings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSettings record ordered by the dateFormat field
        usersettings = await UserSettings.prisma().find_first_or_raise(
            skip=1,
            order={
                'dateFormat': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSettingsUpdateInput,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSettings record.

        Parameters
        ----------
        data
            UserSettings record data specifying what to update
        where
            UserSettings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The updated UserSettings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().update(
            where={
                'id': 'efggddide',
            },
            data={
                # data to update the UserSettings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSettingsWhereUniqueInput,
        data: types.UserSettingsUpsertInput,
        include: Optional[types.UserSettingsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSettings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The created or updated UserSettings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().upsert(
            where={
                'id': 'caficfigfb',
            },
            data={
                'create': {
                    'id': 'caficfigfb',
                    'userId': 'ijdbeffgg',
                },
                'update': {
                    'userId': 'ijdbeffgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSettingsUpdateManyMutationInput,
        where: types.UserSettingsWhereInput,
    ) -> int:
        """Update multiple UserSettings records

        Parameters
        ----------
        data
            UserSettings data to update the selected UserSettings records to
        where
            Filter to select the UserSettings records to update

        Returns
        -------
        int
            The total number of UserSettings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSettings records
        total = await UserSettings.prisma().update_many(
            data={
                'autoSave': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSettings records present in the database

        Parameters
        ----------
        select
            Select the UserSettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSettings.prisma().count()

        # results: prisma.types.UserSettingsCountAggregateOutput
        results = await UserSettings.prisma().count(
            select={
                '_all': True,
                'emailDailyDigest': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSettingsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
    ) -> types.UserSettingsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSettingsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
    ) -> Union[int, types.UserSettingsCountAggregateOutput]:
        """Count the number of UserSettings records present in the database

        Parameters
        ----------
        select
            Select the UserSettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSettings.prisma().count()

        # results: prisma.types.UserSettingsCountAggregateOutput
        results = await UserSettings.prisma().count(
            select={
                '_all': True,
                'emailNewCandidateAlerts': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSettingsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSettingsWhereInput] = None
    ) -> int:
        """Delete multiple UserSettings records.

        Parameters
        ----------
        where
            Optional UserSettings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSettings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSettings records
        total = await UserSettings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSettingsScalarFieldKeys'],
        *,
        where: Optional['types.UserSettingsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSettingsAvgAggregateInput'] = None,
        sum: Optional['types.UserSettingsSumAggregateInput'] = None,
        min: Optional['types.UserSettingsMinAggregateInput'] = None,
        max: Optional['types.UserSettingsMaxAggregateInput'] = None,
        having: Optional['types.UserSettingsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSettingsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSettingsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSettingsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSettingsGroupByOutput']:
        """Group UserSettings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSettings fields to group records by
        where
            UserSettings filter to select records
        take
            Limit the maximum number of UserSettings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSettingsGroupByOutput]
            A list of dictionaries representing the UserSettings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSettings records by emailMarketingEmails values
        # and count how many records are in each group
        results = await UserSettings.prisma().group_by(
            ['emailMarketingEmails'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Company]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Company.prisma().query_raw(
            'SELECT * FROM Company WHERE id = $1',
            'ihieecagf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Company
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Company.prisma().query_first(
            'SELECT * FROM Company WHERE userId = $1',
            'bghfciaafe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CompanyCreateInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new Company record.

        Parameters
        ----------
        data
            Company record data
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created Company record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Company record from just the required fields
        company = await Company.prisma().create(
            data={
                # data to create a Company record
                'userId': 'bgchfhgceh',
                'name': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Company records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Company record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Company.prisma().create_many(
            data=[
                {
                    # data to create a Company record
                    'userId': 'gaddfhfh',
                    'name': 'gieegcbeg',
                },
                {
                    # data to create a Company record
                    'userId': 'bgcffadich',
                    'name': 'fcbichhci',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Company record.

        Parameters
        ----------
        where
            Company filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The deleted Company record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().delete(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Company record.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Company record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique_or_raise(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Company records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N results
        where
            Company filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Company]
            The list of all Company records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Company records
        companys = await Company.prisma().find_many(take=10)

        # find the first 5 Company records ordered by the name field
        companys = await Company.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Company record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the description field
        company = await Company.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Company record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the industry field
        company = await Company.prisma().find_first_or_raise(
            skip=1,
            order={
                'industry': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CompanyUpdateInput,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Company record.

        Parameters
        ----------
        data
            Company record data specifying what to update
        where
            Company filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The updated Company record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        company = await Company.prisma().update(
            where={
                'id': 'gifdddbia',
            },
            data={
                # data to update the Company record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CompanyWhereUniqueInput,
        data: types.CompanyUpsertInput,
        include: Optional[types.CompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Company filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created or updated Company record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().upsert(
            where={
                'id': 'bchehecef',
            },
            data={
                'create': {
                    'id': 'bchehecef',
                    'userId': 'bgcffadich',
                    'name': 'fcbichhci',
                },
                'update': {
                    'userId': 'bgcffadich',
                    'name': 'fcbichhci',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CompanyUpdateManyMutationInput,
        where: types.CompanyWhereInput,
    ) -> int:
        """Update multiple Company records

        Parameters
        ----------
        data
            Company data to update the selected Company records to
        where
            Filter to select the Company records to update

        Returns
        -------
        int
            The total number of Company records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Company records
        total = await Company.prisma().update_many(
            data={
                'founded': 948921754
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'companySize': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> types.CompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> Union[int, types.CompanyCountAggregateOutput]:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'website': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CompanyWhereInput] = None
    ) -> int:
        """Delete multiple Company records.

        Parameters
        ----------
        where
            Optional Company filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Company records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Company records
        total = await Company.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CompanyScalarFieldKeys'],
        *,
        where: Optional['types.CompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CompanyAvgAggregateInput'] = None,
        sum: Optional['types.CompanySumAggregateInput'] = None,
        min: Optional['types.CompanyMinAggregateInput'] = None,
        max: Optional['types.CompanyMaxAggregateInput'] = None,
        having: Optional['types.CompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CompanyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CompanyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CompanyGroupByOutput']:
        """Group Company records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Company fields to group records by
        where
            Company filter to select records
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CompanyGroupByOutput]
            A list of dictionaries representing the Company record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Company records by email values
        # and count how many records are in each group
        results = await Company.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CompanyLocationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CompanyLocation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CompanyLocation.prisma().query_raw(
            'SELECT * FROM CompanyLocation WHERE id = $1',
            'bjgejjabff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CompanyLocation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CompanyLocation.prisma().query_first(
            'SELECT * FROM CompanyLocation WHERE companyId = $1',
            'bcciijbibg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CompanyLocationCreateInput,
        include: Optional[types.CompanyLocationInclude] = None
    ) -> _PrismaModelT:
        """Create a new CompanyLocation record.

        Parameters
        ----------
        data
            CompanyLocation record data
        include
            Specifies which relations should be loaded on the returned CompanyLocation model

        Returns
        -------
        prisma.models.CompanyLocation
            The created CompanyLocation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CompanyLocation record from just the required fields
        companylocation = await CompanyLocation.prisma().create(
            data={
                # data to create a CompanyLocation record
                'companyId': 'cffcachfd',
                'name': 'bccdfhdigc',
                'address': 'febcgjbfj',
                'city': 'bageiegghg',
                'country': 'faidicegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CompanyLocationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CompanyLocation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CompanyLocation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CompanyLocation.prisma().create_many(
            data=[
                {
                    # data to create a CompanyLocation record
                    'companyId': 'bacecgfhbe',
                    'name': 'ihcahiead',
                    'address': 'biheheiajg',
                    'city': 'jbgijghgb',
                    'country': 'hgjcghfbi',
                },
                {
                    # data to create a CompanyLocation record
                    'companyId': 'icadbcehj',
                    'name': 'jchciaee',
                    'address': 'deeificjd',
                    'city': 'bbcbhebbda',
                    'country': 'bejfijgcfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CompanyLocationWhereUniqueInput,
        include: Optional[types.CompanyLocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CompanyLocation record.

        Parameters
        ----------
        where
            CompanyLocation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CompanyLocation model

        Returns
        -------
        prisma.models.CompanyLocation
            The deleted CompanyLocation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companylocation = await CompanyLocation.prisma().delete(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CompanyLocationWhereUniqueInput,
        include: Optional[types.CompanyLocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CompanyLocation record.

        Parameters
        ----------
        where
            CompanyLocation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CompanyLocation model

        Returns
        -------
        prisma.models.CompanyLocation
            The found CompanyLocation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companylocation = await CompanyLocation.prisma().find_unique(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CompanyLocationWhereUniqueInput,
        include: Optional[types.CompanyLocationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CompanyLocation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CompanyLocation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CompanyLocation model

        Returns
        -------
        prisma.models.CompanyLocation
            The found CompanyLocation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companylocation = await CompanyLocation.prisma().find_unique_or_raise(
            where={
                'id': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyLocationWhereInput] = None,
        cursor: Optional[types.CompanyLocationWhereUniqueInput] = None,
        include: Optional[types.CompanyLocationInclude] = None,
        order: Optional[Union[types.CompanyLocationOrderByInput, List[types.CompanyLocationOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyLocationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CompanyLocation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CompanyLocation records returned
        skip
            Ignore the first N results
        where
            CompanyLocation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CompanyLocation model
        order
            Order the returned CompanyLocation records by any field
        distinct
            Filter CompanyLocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CompanyLocation]
            The list of all CompanyLocation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CompanyLocation records
        companylocations = await CompanyLocation.prisma().find_many(take=10)

        # find the first 5 CompanyLocation records ordered by the name field
        companylocations = await CompanyLocation.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyLocationWhereInput] = None,
        cursor: Optional[types.CompanyLocationWhereUniqueInput] = None,
        include: Optional[types.CompanyLocationInclude] = None,
        order: Optional[Union[types.CompanyLocationOrderByInput, List[types.CompanyLocationOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyLocationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CompanyLocation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CompanyLocation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CompanyLocation model
        order
            Order the returned CompanyLocation records by any field
        distinct
            Filter CompanyLocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CompanyLocation
            The first CompanyLocation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CompanyLocation record ordered by the type field
        companylocation = await CompanyLocation.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyLocationWhereInput] = None,
        cursor: Optional[types.CompanyLocationWhereUniqueInput] = None,
        include: Optional[types.CompanyLocationInclude] = None,
        order: Optional[Union[types.CompanyLocationOrderByInput, List[types.CompanyLocationOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyLocationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CompanyLocation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CompanyLocation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CompanyLocation model
        order
            Order the returned CompanyLocation records by any field
        distinct
            Filter CompanyLocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CompanyLocation
            The first CompanyLocation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CompanyLocation record ordered by the address field
        companylocation = await CompanyLocation.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CompanyLocationUpdateInput,
        where: types.CompanyLocationWhereUniqueInput,
        include: Optional[types.CompanyLocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CompanyLocation record.

        Parameters
        ----------
        data
            CompanyLocation record data specifying what to update
        where
            CompanyLocation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CompanyLocation model

        Returns
        -------
        prisma.models.CompanyLocation
            The updated CompanyLocation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        companylocation = await CompanyLocation.prisma().update(
            where={
                'id': 'fcfhgbjed',
            },
            data={
                # data to update the CompanyLocation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CompanyLocationWhereUniqueInput,
        data: types.CompanyLocationUpsertInput,
        include: Optional[types.CompanyLocationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CompanyLocation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CompanyLocation model

        Returns
        -------
        prisma.models.CompanyLocation
            The created or updated CompanyLocation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companylocation = await CompanyLocation.prisma().upsert(
            where={
                'id': 'hdgcajhjg',
            },
            data={
                'create': {
                    'id': 'hdgcajhjg',
                    'companyId': 'icadbcehj',
                    'name': 'jchciaee',
                    'address': 'deeificjd',
                    'city': 'bbcbhebbda',
                    'country': 'bejfijgcfb',
                },
                'update': {
                    'companyId': 'icadbcehj',
                    'name': 'jchciaee',
                    'address': 'deeificjd',
                    'city': 'bbcbhebbda',
                    'country': 'bejfijgcfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CompanyLocationUpdateManyMutationInput,
        where: types.CompanyLocationWhereInput,
    ) -> int:
        """Update multiple CompanyLocation records

        Parameters
        ----------
        data
            CompanyLocation data to update the selected CompanyLocation records to
        where
            Filter to select the CompanyLocation records to update

        Returns
        -------
        int
            The total number of CompanyLocation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CompanyLocation records
        total = await CompanyLocation.prisma().update_many(
            data={
                'city': 'ejdjahicb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyLocationWhereInput] = None,
        cursor: Optional[types.CompanyLocationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CompanyLocation records present in the database

        Parameters
        ----------
        select
            Select the CompanyLocation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CompanyLocation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyLocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CompanyLocation.prisma().count()

        # results: prisma.types.CompanyLocationCountAggregateOutput
        results = await CompanyLocation.prisma().count(
            select={
                '_all': True,
                'state': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CompanyLocationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyLocationWhereInput] = None,
        cursor: Optional[types.CompanyLocationWhereUniqueInput] = None,
    ) -> types.CompanyLocationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CompanyLocationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyLocationWhereInput] = None,
        cursor: Optional[types.CompanyLocationWhereUniqueInput] = None,
    ) -> Union[int, types.CompanyLocationCountAggregateOutput]:
        """Count the number of CompanyLocation records present in the database

        Parameters
        ----------
        select
            Select the CompanyLocation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CompanyLocation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyLocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CompanyLocation.prisma().count()

        # results: prisma.types.CompanyLocationCountAggregateOutput
        results = await CompanyLocation.prisma().count(
            select={
                '_all': True,
                'country': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CompanyLocationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CompanyLocationWhereInput] = None
    ) -> int:
        """Delete multiple CompanyLocation records.

        Parameters
        ----------
        where
            Optional CompanyLocation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CompanyLocation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CompanyLocation records
        total = await CompanyLocation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CompanyLocationScalarFieldKeys'],
        *,
        where: Optional['types.CompanyLocationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CompanyLocationAvgAggregateInput'] = None,
        sum: Optional['types.CompanyLocationSumAggregateInput'] = None,
        min: Optional['types.CompanyLocationMinAggregateInput'] = None,
        max: Optional['types.CompanyLocationMaxAggregateInput'] = None,
        having: Optional['types.CompanyLocationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CompanyLocationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CompanyLocationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CompanyLocationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CompanyLocationGroupByOutput']:
        """Group CompanyLocation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CompanyLocation fields to group records by
        where
            CompanyLocation filter to select records
        take
            Limit the maximum number of CompanyLocation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CompanyLocationGroupByOutput]
            A list of dictionaries representing the CompanyLocation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CompanyLocation records by zipCode values
        # and count how many records are in each group
        results = await CompanyLocation.prisma().group_by(
            ['zipCode'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamMember]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TeamMember.prisma().query_raw(
            'SELECT * FROM TeamMember WHERE id = $1',
            'gdjgigfgc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamMember
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TeamMember.prisma().query_first(
            'SELECT * FROM TeamMember WHERE companyId = $1',
            'gfeaahdeh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamMemberCreateInput,
        include: Optional[types.TeamMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamMember record.

        Parameters
        ----------
        data
            TeamMember record data
        include
            Specifies which relations should be loaded on the returned TeamMember model

        Returns
        -------
        prisma.models.TeamMember
            The created TeamMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamMember record from just the required fields
        teammember = await TeamMember.prisma().create(
            data={
                # data to create a TeamMember record
                'companyId': 'bjafcgbffc',
                'name': 'hihegjif',
                'email': 'bdjidcidac',
                'role': 'ifgaaagff',
                'department': 'befcddgjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TeamMember.prisma().create_many(
            data=[
                {
                    # data to create a TeamMember record
                    'companyId': 'bfhdbjjgfd',
                    'name': 'cabdjadaji',
                    'email': 'faajgfadf',
                    'role': 'biaagcedjc',
                    'department': 'cahhaghecf',
                },
                {
                    # data to create a TeamMember record
                    'companyId': 'bghcbbcidi',
                    'name': 'jcgghhgdj',
                    'email': 'beehgcebbg',
                    'role': 'bhdiaidiaf',
                    'department': 'deajegcfi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamMemberWhereUniqueInput,
        include: Optional[types.TeamMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamMember record.

        Parameters
        ----------
        where
            TeamMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamMember model

        Returns
        -------
        prisma.models.TeamMember
            The deleted TeamMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammember = await TeamMember.prisma().delete(
            where={
                'id': 'gabahhhjf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamMemberWhereUniqueInput,
        include: Optional[types.TeamMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamMember record.

        Parameters
        ----------
        where
            TeamMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamMember model

        Returns
        -------
        prisma.models.TeamMember
            The found TeamMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammember = await TeamMember.prisma().find_unique(
            where={
                'id': 'cjagadcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamMemberWhereUniqueInput,
        include: Optional[types.TeamMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamMember model

        Returns
        -------
        prisma.models.TeamMember
            The found TeamMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammember = await TeamMember.prisma().find_unique_or_raise(
            where={
                'id': 'bifficggej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamMemberWhereInput] = None,
        cursor: Optional[types.TeamMemberWhereUniqueInput] = None,
        include: Optional[types.TeamMemberInclude] = None,
        order: Optional[Union[types.TeamMemberOrderByInput, List[types.TeamMemberOrderByInput]]] = None,
        distinct: Optional[List[types.TeamMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamMember records returned
        skip
            Ignore the first N results
        where
            TeamMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamMember model
        order
            Order the returned TeamMember records by any field
        distinct
            Filter TeamMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamMember]
            The list of all TeamMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamMember records
        teammembers = await TeamMember.prisma().find_many(take=10)

        # find the first 5 TeamMember records ordered by the name field
        teammembers = await TeamMember.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamMemberWhereInput] = None,
        cursor: Optional[types.TeamMemberWhereUniqueInput] = None,
        include: Optional[types.TeamMemberInclude] = None,
        order: Optional[Union[types.TeamMemberOrderByInput, List[types.TeamMemberOrderByInput]]] = None,
        distinct: Optional[List[types.TeamMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamMember model
        order
            Order the returned TeamMember records by any field
        distinct
            Filter TeamMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamMember
            The first TeamMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamMember record ordered by the email field
        teammember = await TeamMember.prisma().find_first(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamMemberWhereInput] = None,
        cursor: Optional[types.TeamMemberWhereUniqueInput] = None,
        include: Optional[types.TeamMemberInclude] = None,
        order: Optional[Union[types.TeamMemberOrderByInput, List[types.TeamMemberOrderByInput]]] = None,
        distinct: Optional[List[types.TeamMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamMember model
        order
            Order the returned TeamMember records by any field
        distinct
            Filter TeamMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamMember
            The first TeamMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamMember record ordered by the role field
        teammember = await TeamMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamMemberUpdateInput,
        where: types.TeamMemberWhereUniqueInput,
        include: Optional[types.TeamMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamMember record.

        Parameters
        ----------
        data
            TeamMember record data specifying what to update
        where
            TeamMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamMember model

        Returns
        -------
        prisma.models.TeamMember
            The updated TeamMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teammember = await TeamMember.prisma().update(
            where={
                'id': 'bgbbaajbic',
            },
            data={
                # data to update the TeamMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamMemberWhereUniqueInput,
        data: types.TeamMemberUpsertInput,
        include: Optional[types.TeamMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamMember model

        Returns
        -------
        prisma.models.TeamMember
            The created or updated TeamMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammember = await TeamMember.prisma().upsert(
            where={
                'id': 'eegghdhjb',
            },
            data={
                'create': {
                    'id': 'eegghdhjb',
                    'companyId': 'bghcbbcidi',
                    'name': 'jcgghhgdj',
                    'email': 'beehgcebbg',
                    'role': 'bhdiaidiaf',
                    'department': 'deajegcfi',
                },
                'update': {
                    'companyId': 'bghcbbcidi',
                    'name': 'jcgghhgdj',
                    'email': 'beehgcebbg',
                    'role': 'bhdiaidiaf',
                    'department': 'deajegcfi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamMemberUpdateManyMutationInput,
        where: types.TeamMemberWhereInput,
    ) -> int:
        """Update multiple TeamMember records

        Parameters
        ----------
        data
            TeamMember data to update the selected TeamMember records to
        where
            Filter to select the TeamMember records to update

        Returns
        -------
        int
            The total number of TeamMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamMember records
        total = await TeamMember.prisma().update_many(
            data={
                'department': 'daafgidjg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamMemberWhereInput] = None,
        cursor: Optional[types.TeamMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamMember records present in the database

        Parameters
        ----------
        select
            Select the TeamMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamMember.prisma().count()

        # results: prisma.types.TeamMemberCountAggregateOutput
        results = await TeamMember.prisma().count(
            select={
                '_all': True,
                'phone': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamMemberWhereInput] = None,
        cursor: Optional[types.TeamMemberWhereUniqueInput] = None,
    ) -> types.TeamMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamMemberWhereInput] = None,
        cursor: Optional[types.TeamMemberWhereUniqueInput] = None,
    ) -> Union[int, types.TeamMemberCountAggregateOutput]:
        """Count the number of TeamMember records present in the database

        Parameters
        ----------
        select
            Select the TeamMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamMember.prisma().count()

        # results: prisma.types.TeamMemberCountAggregateOutput
        results = await TeamMember.prisma().count(
            select={
                '_all': True,
                'avatar': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamMemberWhereInput] = None
    ) -> int:
        """Delete multiple TeamMember records.

        Parameters
        ----------
        where
            Optional TeamMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamMember records
        total = await TeamMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamMemberScalarFieldKeys'],
        *,
        where: Optional['types.TeamMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamMemberAvgAggregateInput'] = None,
        sum: Optional['types.TeamMemberSumAggregateInput'] = None,
        min: Optional['types.TeamMemberMinAggregateInput'] = None,
        max: Optional['types.TeamMemberMaxAggregateInput'] = None,
        having: Optional['types.TeamMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TeamMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamMemberGroupByOutput']:
        """Group TeamMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamMember fields to group records by
        where
            TeamMember filter to select records
        take
            Limit the maximum number of TeamMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamMemberGroupByOutput]
            A list of dictionaries representing the TeamMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamMember records by status values
        # and count how many records are in each group
        results = await TeamMember.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SubscriptionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Subscription]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Subscription.prisma().query_raw(
            'SELECT * FROM Subscription WHERE id = $1',
            'gdcgcgagj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Subscription
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Subscription.prisma().query_first(
            'SELECT * FROM Subscription WHERE companyId = $1',
            'bhceabbgja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SubscriptionCreateInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Subscription record.

        Parameters
        ----------
        data
            Subscription record data
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The created Subscription record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Subscription record from just the required fields
        subscription = await Subscription.prisma().create(
            data={
                # data to create a Subscription record
                'companyId': 'ehabfhegh',
                'planName': 'bcajcajjbc',
                'planPrice': Decimal('1536744465.42421'),
                'currentPeriodStart': datetime.datetime.utcnow(),
                'currentPeriodEnd': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SubscriptionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Subscription records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Subscription record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Subscription.prisma().create_many(
            data=[
                {
                    # data to create a Subscription record
                    'companyId': 'cbcfgdcdhf',
                    'planName': 'fdgjfbhia',
                    'planPrice': Decimal('924723277.162193'),
                    'currentPeriodStart': datetime.datetime.utcnow(),
                    'currentPeriodEnd': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Subscription record
                    'companyId': 'bieiidcabj',
                    'planName': 'bjcbfcieaa',
                    'planPrice': Decimal('2100427849.84914'),
                    'currentPeriodStart': datetime.datetime.utcnow(),
                    'currentPeriodEnd': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Subscription record.

        Parameters
        ----------
        where
            Subscription filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The deleted Subscription record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().delete(
            where={
                'id': 'jcibfcbhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Subscription record.

        Parameters
        ----------
        where
            Subscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The found Subscription record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().find_unique(
            where={
                'id': 'chdadcaga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Subscription record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Subscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The found Subscription record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().find_unique_or_raise(
            where={
                'id': 'jicieifbh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
        include: Optional[types.SubscriptionInclude] = None,
        order: Optional[Union[types.SubscriptionOrderByInput, List[types.SubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Subscription records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Subscription records returned
        skip
            Ignore the first N results
        where
            Subscription filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Subscription model
        order
            Order the returned Subscription records by any field
        distinct
            Filter Subscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Subscription]
            The list of all Subscription records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Subscription records
        subscriptions = await Subscription.prisma().find_many(take=10)

        # find the first 5 Subscription records ordered by the planName field
        subscriptions = await Subscription.prisma().find_many(
            take=5,
            order={
                'planName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
        include: Optional[types.SubscriptionInclude] = None,
        order: Optional[Union[types.SubscriptionOrderByInput, List[types.SubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Subscription record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Subscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Subscription model
        order
            Order the returned Subscription records by any field
        distinct
            Filter Subscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Subscription
            The first Subscription record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Subscription record ordered by the planPrice field
        subscription = await Subscription.prisma().find_first(
            skip=1,
            order={
                'planPrice': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
        include: Optional[types.SubscriptionInclude] = None,
        order: Optional[Union[types.SubscriptionOrderByInput, List[types.SubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Subscription record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Subscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Subscription model
        order
            Order the returned Subscription records by any field
        distinct
            Filter Subscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Subscription
            The first Subscription record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Subscription record ordered by the billingCycle field
        subscription = await Subscription.prisma().find_first_or_raise(
            skip=1,
            order={
                'billingCycle': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SubscriptionUpdateInput,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Subscription record.

        Parameters
        ----------
        data
            Subscription record data specifying what to update
        where
            Subscription filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The updated Subscription record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        subscription = await Subscription.prisma().update(
            where={
                'id': 'fbahdheji',
            },
            data={
                # data to update the Subscription record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SubscriptionWhereUniqueInput,
        data: types.SubscriptionUpsertInput,
        include: Optional[types.SubscriptionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Subscription filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The created or updated Subscription record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().upsert(
            where={
                'id': 'cbbheiicgh',
            },
            data={
                'create': {
                    'id': 'cbbheiicgh',
                    'companyId': 'bieiidcabj',
                    'planName': 'bjcbfcieaa',
                    'planPrice': Decimal('2100427849.84914'),
                    'currentPeriodStart': datetime.datetime.utcnow(),
                    'currentPeriodEnd': datetime.datetime.utcnow(),
                },
                'update': {
                    'companyId': 'bieiidcabj',
                    'planName': 'bjcbfcieaa',
                    'planPrice': Decimal('2100427849.84914'),
                    'currentPeriodStart': datetime.datetime.utcnow(),
                    'currentPeriodEnd': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SubscriptionUpdateManyMutationInput,
        where: types.SubscriptionWhereInput,
    ) -> int:
        """Update multiple Subscription records

        Parameters
        ----------
        data
            Subscription data to update the selected Subscription records to
        where
            Filter to select the Subscription records to update

        Returns
        -------
        int
            The total number of Subscription records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Subscription records
        total = await Subscription.prisma().update_many(
            data={
                'status': 'beabjeejdg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Subscription records present in the database

        Parameters
        ----------
        select
            Select the Subscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Subscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Subscription.prisma().count()

        # results: prisma.types.SubscriptionCountAggregateOutput
        results = await Subscription.prisma().count(
            select={
                '_all': True,
                'currentPeriodStart': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SubscriptionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
    ) -> types.SubscriptionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SubscriptionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
    ) -> Union[int, types.SubscriptionCountAggregateOutput]:
        """Count the number of Subscription records present in the database

        Parameters
        ----------
        select
            Select the Subscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Subscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Subscription.prisma().count()

        # results: prisma.types.SubscriptionCountAggregateOutput
        results = await Subscription.prisma().count(
            select={
                '_all': True,
                'currentPeriodEnd': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SubscriptionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SubscriptionWhereInput] = None
    ) -> int:
        """Delete multiple Subscription records.

        Parameters
        ----------
        where
            Optional Subscription filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Subscription records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Subscription records
        total = await Subscription.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SubscriptionScalarFieldKeys'],
        *,
        where: Optional['types.SubscriptionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SubscriptionAvgAggregateInput'] = None,
        sum: Optional['types.SubscriptionSumAggregateInput'] = None,
        min: Optional['types.SubscriptionMinAggregateInput'] = None,
        max: Optional['types.SubscriptionMaxAggregateInput'] = None,
        having: Optional['types.SubscriptionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SubscriptionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SubscriptionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SubscriptionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SubscriptionGroupByOutput']:
        """Group Subscription records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Subscription fields to group records by
        where
            Subscription filter to select records
        take
            Limit the maximum number of Subscription records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SubscriptionGroupByOutput]
            A list of dictionaries representing the Subscription record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Subscription records by cancelAtPeriodEnd values
        # and count how many records are in each group
        results = await Subscription.prisma().group_by(
            ['cancelAtPeriodEnd'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentMethodActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PaymentMethod]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PaymentMethod.prisma().query_raw(
            'SELECT * FROM PaymentMethod WHERE id = $1',
            'bcjhgahffd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PaymentMethod
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PaymentMethod.prisma().query_first(
            'SELECT * FROM PaymentMethod WHERE companyId = $1',
            'fbjeiiffa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentMethodCreateInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> _PrismaModelT:
        """Create a new PaymentMethod record.

        Parameters
        ----------
        data
            PaymentMethod record data
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The created PaymentMethod record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PaymentMethod record from just the required fields
        paymentmethod = await PaymentMethod.prisma().create(
            data={
                # data to create a PaymentMethod record
                'companyId': 'jhgidcgbf',
                'last4': 'bgjgecfejc',
                'brand': 'bgjcgchib',
                'expiryMonth': 1023081650,
                'expiryYear': 327681027,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentMethodCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PaymentMethod records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PaymentMethod record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PaymentMethod.prisma().create_many(
            data=[
                {
                    # data to create a PaymentMethod record
                    'companyId': 'fchheijjc',
                    'last4': 'cacjdfhejh',
                    'brand': 'bdbifjhbbi',
                    'expiryMonth': 2122112351,
                    'expiryYear': 1024943020,
                },
                {
                    # data to create a PaymentMethod record
                    'companyId': 'bhbhdahfaj',
                    'last4': 'bfjibceaec',
                    'brand': 'ibhgcdbgd',
                    'expiryMonth': 1030557336,
                    'expiryYear': 1131525873,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PaymentMethod record.

        Parameters
        ----------
        where
            PaymentMethod filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The deleted PaymentMethod record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().delete(
            where={
                'id': 'cbagggbji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PaymentMethod record.

        Parameters
        ----------
        where
            PaymentMethod filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The found PaymentMethod record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().find_unique(
            where={
                'id': 'bchgafhjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PaymentMethod record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PaymentMethod filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The found PaymentMethod record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().find_unique_or_raise(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
        include: Optional[types.PaymentMethodInclude] = None,
        order: Optional[Union[types.PaymentMethodOrderByInput, List[types.PaymentMethodOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentMethodScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PaymentMethod records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PaymentMethod records returned
        skip
            Ignore the first N results
        where
            PaymentMethod filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PaymentMethod model
        order
            Order the returned PaymentMethod records by any field
        distinct
            Filter PaymentMethod records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PaymentMethod]
            The list of all PaymentMethod records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PaymentMethod records
        paymentmethods = await PaymentMethod.prisma().find_many(take=10)

        # find the first 5 PaymentMethod records ordered by the type field
        paymentmethods = await PaymentMethod.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
        include: Optional[types.PaymentMethodInclude] = None,
        order: Optional[Union[types.PaymentMethodOrderByInput, List[types.PaymentMethodOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentMethodScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PaymentMethod record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PaymentMethod filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PaymentMethod model
        order
            Order the returned PaymentMethod records by any field
        distinct
            Filter PaymentMethod records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PaymentMethod
            The first PaymentMethod record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PaymentMethod record ordered by the last4 field
        paymentmethod = await PaymentMethod.prisma().find_first(
            skip=1,
            order={
                'last4': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
        include: Optional[types.PaymentMethodInclude] = None,
        order: Optional[Union[types.PaymentMethodOrderByInput, List[types.PaymentMethodOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentMethodScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PaymentMethod record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PaymentMethod filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PaymentMethod model
        order
            Order the returned PaymentMethod records by any field
        distinct
            Filter PaymentMethod records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PaymentMethod
            The first PaymentMethod record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PaymentMethod record ordered by the brand field
        paymentmethod = await PaymentMethod.prisma().find_first_or_raise(
            skip=1,
            order={
                'brand': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentMethodUpdateInput,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PaymentMethod record.

        Parameters
        ----------
        data
            PaymentMethod record data specifying what to update
        where
            PaymentMethod filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The updated PaymentMethod record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().update(
            where={
                'id': 'dahihgbeb',
            },
            data={
                # data to update the PaymentMethod record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        data: types.PaymentMethodUpsertInput,
        include: Optional[types.PaymentMethodInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PaymentMethod filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The created or updated PaymentMethod record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().upsert(
            where={
                'id': 'bgheaejbcc',
            },
            data={
                'create': {
                    'id': 'bgheaejbcc',
                    'companyId': 'bhbhdahfaj',
                    'last4': 'bfjibceaec',
                    'brand': 'ibhgcdbgd',
                    'expiryMonth': 1030557336,
                    'expiryYear': 1131525873,
                },
                'update': {
                    'companyId': 'bhbhdahfaj',
                    'last4': 'bfjibceaec',
                    'brand': 'ibhgcdbgd',
                    'expiryMonth': 1030557336,
                    'expiryYear': 1131525873,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentMethodUpdateManyMutationInput,
        where: types.PaymentMethodWhereInput,
    ) -> int:
        """Update multiple PaymentMethod records

        Parameters
        ----------
        data
            PaymentMethod data to update the selected PaymentMethod records to
        where
            Filter to select the PaymentMethod records to update

        Returns
        -------
        int
            The total number of PaymentMethod records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PaymentMethod records
        total = await PaymentMethod.prisma().update_many(
            data={
                'expiryMonth': 1526854643
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PaymentMethod records present in the database

        Parameters
        ----------
        select
            Select the PaymentMethod fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PaymentMethod filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentMethodCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PaymentMethod.prisma().count()

        # results: prisma.types.PaymentMethodCountAggregateOutput
        results = await PaymentMethod.prisma().count(
            select={
                '_all': True,
                'expiryYear': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentMethodCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
    ) -> types.PaymentMethodCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentMethodCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentMethodCountAggregateOutput]:
        """Count the number of PaymentMethod records present in the database

        Parameters
        ----------
        select
            Select the PaymentMethod fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PaymentMethod filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentMethodCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PaymentMethod.prisma().count()

        # results: prisma.types.PaymentMethodCountAggregateOutput
        results = await PaymentMethod.prisma().count(
            select={
                '_all': True,
                'isDefault': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentMethodCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentMethodWhereInput] = None
    ) -> int:
        """Delete multiple PaymentMethod records.

        Parameters
        ----------
        where
            Optional PaymentMethod filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PaymentMethod records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PaymentMethod records
        total = await PaymentMethod.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentMethodScalarFieldKeys'],
        *,
        where: Optional['types.PaymentMethodWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentMethodAvgAggregateInput'] = None,
        sum: Optional['types.PaymentMethodSumAggregateInput'] = None,
        min: Optional['types.PaymentMethodMinAggregateInput'] = None,
        max: Optional['types.PaymentMethodMaxAggregateInput'] = None,
        having: Optional['types.PaymentMethodScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentMethodCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentMethodScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PaymentMethodScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentMethodGroupByOutput']:
        """Group PaymentMethod records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PaymentMethod fields to group records by
        where
            PaymentMethod filter to select records
        take
            Limit the maximum number of PaymentMethod records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentMethodGroupByOutput]
            A list of dictionaries representing the PaymentMethod record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PaymentMethod records by stripePaymentMethodId values
        # and count how many records are in each group
        results = await PaymentMethod.prisma().group_by(
            ['stripePaymentMethodId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BillingAddressActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BillingAddress]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BillingAddress.prisma().query_raw(
            'SELECT * FROM BillingAddress WHERE id = $1',
            'jfiahhbae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BillingAddress
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BillingAddress.prisma().query_first(
            'SELECT * FROM BillingAddress WHERE companyId = $1',
            'bfbdafajcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BillingAddressCreateInput,
        include: Optional[types.BillingAddressInclude] = None
    ) -> _PrismaModelT:
        """Create a new BillingAddress record.

        Parameters
        ----------
        data
            BillingAddress record data
        include
            Specifies which relations should be loaded on the returned BillingAddress model

        Returns
        -------
        prisma.models.BillingAddress
            The created BillingAddress record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BillingAddress record from just the required fields
        billingaddress = await BillingAddress.prisma().create(
            data={
                # data to create a BillingAddress record
                'companyId': 'caeghehde',
                'contactName': 'caghgfbggd',
                'contactEmail': 'bbidjbbjaa',
                'companyName': 'bfijhaejdd',
                'addressLine1': 'bcedehfiji',
                'city': 'bdgjicijhb',
                'zipCode': 'bghifjdeia',
                'country': 'eadfcbbcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BillingAddressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BillingAddress records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BillingAddress record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BillingAddress.prisma().create_many(
            data=[
                {
                    # data to create a BillingAddress record
                    'companyId': 'geihgahba',
                    'contactName': 'gahdcdhbj',
                    'contactEmail': 'begiijahea',
                    'companyName': 'gcjadjaaf',
                    'addressLine1': 'bcbebgiaic',
                    'city': 'ijigbdcbj',
                    'zipCode': 'gfidhicai',
                    'country': 'jfegcaafh',
                },
                {
                    # data to create a BillingAddress record
                    'companyId': 'bcbeiajjfa',
                    'contactName': 'baehicaajf',
                    'contactEmail': 'bdachdeiga',
                    'companyName': 'ijdafccef',
                    'addressLine1': 'ciaaiddag',
                    'city': 'fejggijff',
                    'zipCode': 'hghjaaai',
                    'country': 'cajicjjdef',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BillingAddressWhereUniqueInput,
        include: Optional[types.BillingAddressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BillingAddress record.

        Parameters
        ----------
        where
            BillingAddress filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BillingAddress model

        Returns
        -------
        prisma.models.BillingAddress
            The deleted BillingAddress record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        billingaddress = await BillingAddress.prisma().delete(
            where={
                'id': 'cefjaadec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BillingAddressWhereUniqueInput,
        include: Optional[types.BillingAddressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BillingAddress record.

        Parameters
        ----------
        where
            BillingAddress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BillingAddress model

        Returns
        -------
        prisma.models.BillingAddress
            The found BillingAddress record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        billingaddress = await BillingAddress.prisma().find_unique(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BillingAddressWhereUniqueInput,
        include: Optional[types.BillingAddressInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BillingAddress record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BillingAddress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BillingAddress model

        Returns
        -------
        prisma.models.BillingAddress
            The found BillingAddress record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        billingaddress = await BillingAddress.prisma().find_unique_or_raise(
            where={
                'id': 'bdiiiabbii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BillingAddressWhereInput] = None,
        cursor: Optional[types.BillingAddressWhereUniqueInput] = None,
        include: Optional[types.BillingAddressInclude] = None,
        order: Optional[Union[types.BillingAddressOrderByInput, List[types.BillingAddressOrderByInput]]] = None,
        distinct: Optional[List[types.BillingAddressScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BillingAddress records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BillingAddress records returned
        skip
            Ignore the first N results
        where
            BillingAddress filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BillingAddress model
        order
            Order the returned BillingAddress records by any field
        distinct
            Filter BillingAddress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BillingAddress]
            The list of all BillingAddress records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BillingAddress records
        billingaddress = await BillingAddress.prisma().find_many(take=10)

        # find the first 5 BillingAddress records ordered by the contactName field
        billingaddress = await BillingAddress.prisma().find_many(
            take=5,
            order={
                'contactName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BillingAddressWhereInput] = None,
        cursor: Optional[types.BillingAddressWhereUniqueInput] = None,
        include: Optional[types.BillingAddressInclude] = None,
        order: Optional[Union[types.BillingAddressOrderByInput, List[types.BillingAddressOrderByInput]]] = None,
        distinct: Optional[List[types.BillingAddressScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BillingAddress record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BillingAddress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BillingAddress model
        order
            Order the returned BillingAddress records by any field
        distinct
            Filter BillingAddress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BillingAddress
            The first BillingAddress record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BillingAddress record ordered by the contactEmail field
        billingaddress = await BillingAddress.prisma().find_first(
            skip=1,
            order={
                'contactEmail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BillingAddressWhereInput] = None,
        cursor: Optional[types.BillingAddressWhereUniqueInput] = None,
        include: Optional[types.BillingAddressInclude] = None,
        order: Optional[Union[types.BillingAddressOrderByInput, List[types.BillingAddressOrderByInput]]] = None,
        distinct: Optional[List[types.BillingAddressScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BillingAddress record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BillingAddress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BillingAddress model
        order
            Order the returned BillingAddress records by any field
        distinct
            Filter BillingAddress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BillingAddress
            The first BillingAddress record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BillingAddress record ordered by the contactPhone field
        billingaddress = await BillingAddress.prisma().find_first_or_raise(
            skip=1,
            order={
                'contactPhone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BillingAddressUpdateInput,
        where: types.BillingAddressWhereUniqueInput,
        include: Optional[types.BillingAddressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BillingAddress record.

        Parameters
        ----------
        data
            BillingAddress record data specifying what to update
        where
            BillingAddress filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BillingAddress model

        Returns
        -------
        prisma.models.BillingAddress
            The updated BillingAddress record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        billingaddress = await BillingAddress.prisma().update(
            where={
                'id': 'hfcfhhadh',
            },
            data={
                # data to update the BillingAddress record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BillingAddressWhereUniqueInput,
        data: types.BillingAddressUpsertInput,
        include: Optional[types.BillingAddressInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BillingAddress filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BillingAddress model

        Returns
        -------
        prisma.models.BillingAddress
            The created or updated BillingAddress record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        billingaddress = await BillingAddress.prisma().upsert(
            where={
                'id': 'bbihggdcji',
            },
            data={
                'create': {
                    'id': 'bbihggdcji',
                    'companyId': 'bcbeiajjfa',
                    'contactName': 'baehicaajf',
                    'contactEmail': 'bdachdeiga',
                    'companyName': 'ijdafccef',
                    'addressLine1': 'ciaaiddag',
                    'city': 'fejggijff',
                    'zipCode': 'hghjaaai',
                    'country': 'cajicjjdef',
                },
                'update': {
                    'companyId': 'bcbeiajjfa',
                    'contactName': 'baehicaajf',
                    'contactEmail': 'bdachdeiga',
                    'companyName': 'ijdafccef',
                    'addressLine1': 'ciaaiddag',
                    'city': 'fejggijff',
                    'zipCode': 'hghjaaai',
                    'country': 'cajicjjdef',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BillingAddressUpdateManyMutationInput,
        where: types.BillingAddressWhereInput,
    ) -> int:
        """Update multiple BillingAddress records

        Parameters
        ----------
        data
            BillingAddress data to update the selected BillingAddress records to
        where
            Filter to select the BillingAddress records to update

        Returns
        -------
        int
            The total number of BillingAddress records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BillingAddress records
        total = await BillingAddress.prisma().update_many(
            data={
                'companyName': 'hgjgibdgd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BillingAddressWhereInput] = None,
        cursor: Optional[types.BillingAddressWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BillingAddress records present in the database

        Parameters
        ----------
        select
            Select the BillingAddress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BillingAddress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BillingAddressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BillingAddress.prisma().count()

        # results: prisma.types.BillingAddressCountAggregateOutput
        results = await BillingAddress.prisma().count(
            select={
                '_all': True,
                'addressLine1': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BillingAddressCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BillingAddressWhereInput] = None,
        cursor: Optional[types.BillingAddressWhereUniqueInput] = None,
    ) -> types.BillingAddressCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BillingAddressCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BillingAddressWhereInput] = None,
        cursor: Optional[types.BillingAddressWhereUniqueInput] = None,
    ) -> Union[int, types.BillingAddressCountAggregateOutput]:
        """Count the number of BillingAddress records present in the database

        Parameters
        ----------
        select
            Select the BillingAddress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BillingAddress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BillingAddressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BillingAddress.prisma().count()

        # results: prisma.types.BillingAddressCountAggregateOutput
        results = await BillingAddress.prisma().count(
            select={
                '_all': True,
                'addressLine2': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BillingAddressCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BillingAddressWhereInput] = None
    ) -> int:
        """Delete multiple BillingAddress records.

        Parameters
        ----------
        where
            Optional BillingAddress filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BillingAddress records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BillingAddress records
        total = await BillingAddress.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BillingAddressScalarFieldKeys'],
        *,
        where: Optional['types.BillingAddressWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BillingAddressAvgAggregateInput'] = None,
        sum: Optional['types.BillingAddressSumAggregateInput'] = None,
        min: Optional['types.BillingAddressMinAggregateInput'] = None,
        max: Optional['types.BillingAddressMaxAggregateInput'] = None,
        having: Optional['types.BillingAddressScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BillingAddressCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BillingAddressScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BillingAddressScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BillingAddressGroupByOutput']:
        """Group BillingAddress records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BillingAddress fields to group records by
        where
            BillingAddress filter to select records
        take
            Limit the maximum number of BillingAddress records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BillingAddressGroupByOutput]
            A list of dictionaries representing the BillingAddress record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BillingAddress records by city values
        # and count how many records are in each group
        results = await BillingAddress.prisma().group_by(
            ['city'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InvoiceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Invoice]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Invoice.prisma().query_raw(
            'SELECT * FROM Invoice WHERE id = $1',
            'bcbecjfice',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Invoice
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Invoice.prisma().query_first(
            'SELECT * FROM Invoice WHERE companyId = $1',
            'bacbebhjjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InvoiceCreateInput,
        include: Optional[types.InvoiceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Invoice record.

        Parameters
        ----------
        data
            Invoice record data
        include
            Specifies which relations should be loaded on the returned Invoice model

        Returns
        -------
        prisma.models.Invoice
            The created Invoice record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Invoice record from just the required fields
        invoice = await Invoice.prisma().create(
            data={
                # data to create a Invoice record
                'companyId': 'dfbfaddhe',
                'invoiceNumber': 'bdcbbieibf',
                'amount': Decimal('369732668.119123'),
                'dueDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InvoiceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Invoice records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Invoice record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Invoice.prisma().create_many(
            data=[
                {
                    # data to create a Invoice record
                    'companyId': 'gchfgbcec',
                    'invoiceNumber': 'bihcjfcjah',
                    'amount': Decimal('1793282088.181439'),
                    'dueDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Invoice record
                    'companyId': 'bjcdajabfa',
                    'invoiceNumber': 'bchhceeeff',
                    'amount': Decimal('1160857300.36123'),
                    'dueDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InvoiceWhereUniqueInput,
        include: Optional[types.InvoiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Invoice record.

        Parameters
        ----------
        where
            Invoice filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Invoice model

        Returns
        -------
        prisma.models.Invoice
            The deleted Invoice record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoice = await Invoice.prisma().delete(
            where={
                'id': 'beagfbbjig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InvoiceWhereUniqueInput,
        include: Optional[types.InvoiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Invoice record.

        Parameters
        ----------
        where
            Invoice filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Invoice model

        Returns
        -------
        prisma.models.Invoice
            The found Invoice record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoice = await Invoice.prisma().find_unique(
            where={
                'id': 'beicihhijb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InvoiceWhereUniqueInput,
        include: Optional[types.InvoiceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Invoice record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Invoice filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Invoice model

        Returns
        -------
        prisma.models.Invoice
            The found Invoice record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoice = await Invoice.prisma().find_unique_or_raise(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InvoiceWhereInput] = None,
        cursor: Optional[types.InvoiceWhereUniqueInput] = None,
        include: Optional[types.InvoiceInclude] = None,
        order: Optional[Union[types.InvoiceOrderByInput, List[types.InvoiceOrderByInput]]] = None,
        distinct: Optional[List[types.InvoiceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Invoice records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Invoice records returned
        skip
            Ignore the first N results
        where
            Invoice filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Invoice model
        order
            Order the returned Invoice records by any field
        distinct
            Filter Invoice records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Invoice]
            The list of all Invoice records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Invoice records
        invoices = await Invoice.prisma().find_many(take=10)

        # find the first 5 Invoice records ordered by the invoiceNumber field
        invoices = await Invoice.prisma().find_many(
            take=5,
            order={
                'invoiceNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InvoiceWhereInput] = None,
        cursor: Optional[types.InvoiceWhereUniqueInput] = None,
        include: Optional[types.InvoiceInclude] = None,
        order: Optional[Union[types.InvoiceOrderByInput, List[types.InvoiceOrderByInput]]] = None,
        distinct: Optional[List[types.InvoiceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Invoice record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Invoice filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Invoice model
        order
            Order the returned Invoice records by any field
        distinct
            Filter Invoice records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Invoice
            The first Invoice record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Invoice record ordered by the amount field
        invoice = await Invoice.prisma().find_first(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InvoiceWhereInput] = None,
        cursor: Optional[types.InvoiceWhereUniqueInput] = None,
        include: Optional[types.InvoiceInclude] = None,
        order: Optional[Union[types.InvoiceOrderByInput, List[types.InvoiceOrderByInput]]] = None,
        distinct: Optional[List[types.InvoiceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Invoice record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Invoice filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Invoice model
        order
            Order the returned Invoice records by any field
        distinct
            Filter Invoice records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Invoice
            The first Invoice record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Invoice record ordered by the currency field
        invoice = await Invoice.prisma().find_first_or_raise(
            skip=1,
            order={
                'currency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InvoiceUpdateInput,
        where: types.InvoiceWhereUniqueInput,
        include: Optional[types.InvoiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Invoice record.

        Parameters
        ----------
        data
            Invoice record data specifying what to update
        where
            Invoice filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Invoice model

        Returns
        -------
        prisma.models.Invoice
            The updated Invoice record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        invoice = await Invoice.prisma().update(
            where={
                'id': 'ccjbbjigf',
            },
            data={
                # data to update the Invoice record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InvoiceWhereUniqueInput,
        data: types.InvoiceUpsertInput,
        include: Optional[types.InvoiceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Invoice filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Invoice model

        Returns
        -------
        prisma.models.Invoice
            The created or updated Invoice record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        invoice = await Invoice.prisma().upsert(
            where={
                'id': 'bhfaabbaha',
            },
            data={
                'create': {
                    'id': 'bhfaabbaha',
                    'companyId': 'bjcdajabfa',
                    'invoiceNumber': 'bchhceeeff',
                    'amount': Decimal('1160857300.36123'),
                    'dueDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'companyId': 'bjcdajabfa',
                    'invoiceNumber': 'bchhceeeff',
                    'amount': Decimal('1160857300.36123'),
                    'dueDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InvoiceUpdateManyMutationInput,
        where: types.InvoiceWhereInput,
    ) -> int:
        """Update multiple Invoice records

        Parameters
        ----------
        data
            Invoice data to update the selected Invoice records to
        where
            Filter to select the Invoice records to update

        Returns
        -------
        int
            The total number of Invoice records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Invoice records
        total = await Invoice.prisma().update_many(
            data={
                'status': 'ebajedhhf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InvoiceWhereInput] = None,
        cursor: Optional[types.InvoiceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Invoice records present in the database

        Parameters
        ----------
        select
            Select the Invoice fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Invoice filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InvoiceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Invoice.prisma().count()

        # results: prisma.types.InvoiceCountAggregateOutput
        results = await Invoice.prisma().count(
            select={
                '_all': True,
                'dueDate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InvoiceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InvoiceWhereInput] = None,
        cursor: Optional[types.InvoiceWhereUniqueInput] = None,
    ) -> types.InvoiceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InvoiceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InvoiceWhereInput] = None,
        cursor: Optional[types.InvoiceWhereUniqueInput] = None,
    ) -> Union[int, types.InvoiceCountAggregateOutput]:
        """Count the number of Invoice records present in the database

        Parameters
        ----------
        select
            Select the Invoice fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Invoice filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InvoiceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Invoice.prisma().count()

        # results: prisma.types.InvoiceCountAggregateOutput
        results = await Invoice.prisma().count(
            select={
                '_all': True,
                'paidAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InvoiceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InvoiceWhereInput] = None
    ) -> int:
        """Delete multiple Invoice records.

        Parameters
        ----------
        where
            Optional Invoice filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Invoice records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Invoice records
        total = await Invoice.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InvoiceScalarFieldKeys'],
        *,
        where: Optional['types.InvoiceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InvoiceAvgAggregateInput'] = None,
        sum: Optional['types.InvoiceSumAggregateInput'] = None,
        min: Optional['types.InvoiceMinAggregateInput'] = None,
        max: Optional['types.InvoiceMaxAggregateInput'] = None,
        having: Optional['types.InvoiceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InvoiceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InvoiceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InvoiceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InvoiceGroupByOutput']:
        """Group Invoice records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Invoice fields to group records by
        where
            Invoice filter to select records
        take
            Limit the maximum number of Invoice records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InvoiceGroupByOutput]
            A list of dictionaries representing the Invoice record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Invoice records by stripeInvoiceId values
        # and count how many records are in each group
        results = await Invoice.prisma().group_by(
            ['stripeInvoiceId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SubscriptionAddonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SubscriptionAddon]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SubscriptionAddon.prisma().query_raw(
            'SELECT * FROM SubscriptionAddon WHERE id = $1',
            'jajacedge',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SubscriptionAddon
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SubscriptionAddon.prisma().query_first(
            'SELECT * FROM SubscriptionAddon WHERE subscriptionId = $1',
            'hffgbabgf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SubscriptionAddonCreateInput,
        include: Optional[types.SubscriptionAddonInclude] = None
    ) -> _PrismaModelT:
        """Create a new SubscriptionAddon record.

        Parameters
        ----------
        data
            SubscriptionAddon record data
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model

        Returns
        -------
        prisma.models.SubscriptionAddon
            The created SubscriptionAddon record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SubscriptionAddon record from just the required fields
        subscriptionaddon = await SubscriptionAddon.prisma().create(
            data={
                # data to create a SubscriptionAddon record
                'subscriptionId': 'biacbiieja',
                'name': 'cjejbgbff',
                'price': Decimal('564073304.38064'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SubscriptionAddonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SubscriptionAddon records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SubscriptionAddon record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SubscriptionAddon.prisma().create_many(
            data=[
                {
                    # data to create a SubscriptionAddon record
                    'subscriptionId': 'badagbgeha',
                    'name': 'ibgebbjch',
                    'price': Decimal('1084099844.107970'),
                },
                {
                    # data to create a SubscriptionAddon record
                    'subscriptionId': 'hffhfabhi',
                    'name': 'bbcigiadhb',
                    'price': Decimal('259061104.111573'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SubscriptionAddonWhereUniqueInput,
        include: Optional[types.SubscriptionAddonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SubscriptionAddon record.

        Parameters
        ----------
        where
            SubscriptionAddon filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model

        Returns
        -------
        prisma.models.SubscriptionAddon
            The deleted SubscriptionAddon record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscriptionaddon = await SubscriptionAddon.prisma().delete(
            where={
                'id': 'bdadhibhec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SubscriptionAddonWhereUniqueInput,
        include: Optional[types.SubscriptionAddonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SubscriptionAddon record.

        Parameters
        ----------
        where
            SubscriptionAddon filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model

        Returns
        -------
        prisma.models.SubscriptionAddon
            The found SubscriptionAddon record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscriptionaddon = await SubscriptionAddon.prisma().find_unique(
            where={
                'id': 'bfhdjaiejf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SubscriptionAddonWhereUniqueInput,
        include: Optional[types.SubscriptionAddonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SubscriptionAddon record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SubscriptionAddon filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model

        Returns
        -------
        prisma.models.SubscriptionAddon
            The found SubscriptionAddon record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscriptionaddon = await SubscriptionAddon.prisma().find_unique_or_raise(
            where={
                'id': 'bbjfijjadg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionAddonWhereInput] = None,
        cursor: Optional[types.SubscriptionAddonWhereUniqueInput] = None,
        include: Optional[types.SubscriptionAddonInclude] = None,
        order: Optional[Union[types.SubscriptionAddonOrderByInput, List[types.SubscriptionAddonOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionAddonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SubscriptionAddon records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SubscriptionAddon records returned
        skip
            Ignore the first N results
        where
            SubscriptionAddon filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model
        order
            Order the returned SubscriptionAddon records by any field
        distinct
            Filter SubscriptionAddon records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SubscriptionAddon]
            The list of all SubscriptionAddon records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SubscriptionAddon records
        subscriptionaddons = await SubscriptionAddon.prisma().find_many(take=10)

        # find the first 5 SubscriptionAddon records ordered by the name field
        subscriptionaddons = await SubscriptionAddon.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionAddonWhereInput] = None,
        cursor: Optional[types.SubscriptionAddonWhereUniqueInput] = None,
        include: Optional[types.SubscriptionAddonInclude] = None,
        order: Optional[Union[types.SubscriptionAddonOrderByInput, List[types.SubscriptionAddonOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionAddonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SubscriptionAddon record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SubscriptionAddon filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model
        order
            Order the returned SubscriptionAddon records by any field
        distinct
            Filter SubscriptionAddon records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SubscriptionAddon
            The first SubscriptionAddon record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SubscriptionAddon record ordered by the description field
        subscriptionaddon = await SubscriptionAddon.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionAddonWhereInput] = None,
        cursor: Optional[types.SubscriptionAddonWhereUniqueInput] = None,
        include: Optional[types.SubscriptionAddonInclude] = None,
        order: Optional[Union[types.SubscriptionAddonOrderByInput, List[types.SubscriptionAddonOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionAddonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SubscriptionAddon record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SubscriptionAddon filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model
        order
            Order the returned SubscriptionAddon records by any field
        distinct
            Filter SubscriptionAddon records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SubscriptionAddon
            The first SubscriptionAddon record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SubscriptionAddon record ordered by the price field
        subscriptionaddon = await SubscriptionAddon.prisma().find_first_or_raise(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SubscriptionAddonUpdateInput,
        where: types.SubscriptionAddonWhereUniqueInput,
        include: Optional[types.SubscriptionAddonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SubscriptionAddon record.

        Parameters
        ----------
        data
            SubscriptionAddon record data specifying what to update
        where
            SubscriptionAddon filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model

        Returns
        -------
        prisma.models.SubscriptionAddon
            The updated SubscriptionAddon record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        subscriptionaddon = await SubscriptionAddon.prisma().update(
            where={
                'id': 'hdjacbehh',
            },
            data={
                # data to update the SubscriptionAddon record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SubscriptionAddonWhereUniqueInput,
        data: types.SubscriptionAddonUpsertInput,
        include: Optional[types.SubscriptionAddonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SubscriptionAddon filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SubscriptionAddon model

        Returns
        -------
        prisma.models.SubscriptionAddon
            The created or updated SubscriptionAddon record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscriptionaddon = await SubscriptionAddon.prisma().upsert(
            where={
                'id': 'bhcccbeaba',
            },
            data={
                'create': {
                    'id': 'bhcccbeaba',
                    'subscriptionId': 'hffhfabhi',
                    'name': 'bbcigiadhb',
                    'price': Decimal('259061104.111573'),
                },
                'update': {
                    'subscriptionId': 'hffhfabhi',
                    'name': 'bbcigiadhb',
                    'price': Decimal('259061104.111573'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SubscriptionAddonUpdateManyMutationInput,
        where: types.SubscriptionAddonWhereInput,
    ) -> int:
        """Update multiple SubscriptionAddon records

        Parameters
        ----------
        data
            SubscriptionAddon data to update the selected SubscriptionAddon records to
        where
            Filter to select the SubscriptionAddon records to update

        Returns
        -------
        int
            The total number of SubscriptionAddon records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SubscriptionAddon records
        total = await SubscriptionAddon.prisma().update_many(
            data={
                'billingCycle': 'bcgjbdgjdj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionAddonWhereInput] = None,
        cursor: Optional[types.SubscriptionAddonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SubscriptionAddon records present in the database

        Parameters
        ----------
        select
            Select the SubscriptionAddon fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SubscriptionAddon filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubscriptionAddonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SubscriptionAddon.prisma().count()

        # results: prisma.types.SubscriptionAddonCountAggregateOutput
        results = await SubscriptionAddon.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SubscriptionAddonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionAddonWhereInput] = None,
        cursor: Optional[types.SubscriptionAddonWhereUniqueInput] = None,
    ) -> types.SubscriptionAddonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SubscriptionAddonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionAddonWhereInput] = None,
        cursor: Optional[types.SubscriptionAddonWhereUniqueInput] = None,
    ) -> Union[int, types.SubscriptionAddonCountAggregateOutput]:
        """Count the number of SubscriptionAddon records present in the database

        Parameters
        ----------
        select
            Select the SubscriptionAddon fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SubscriptionAddon filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubscriptionAddonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SubscriptionAddon.prisma().count()

        # results: prisma.types.SubscriptionAddonCountAggregateOutput
        results = await SubscriptionAddon.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SubscriptionAddonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SubscriptionAddonWhereInput] = None
    ) -> int:
        """Delete multiple SubscriptionAddon records.

        Parameters
        ----------
        where
            Optional SubscriptionAddon filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SubscriptionAddon records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SubscriptionAddon records
        total = await SubscriptionAddon.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SubscriptionAddonScalarFieldKeys'],
        *,
        where: Optional['types.SubscriptionAddonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SubscriptionAddonAvgAggregateInput'] = None,
        sum: Optional['types.SubscriptionAddonSumAggregateInput'] = None,
        min: Optional['types.SubscriptionAddonMinAggregateInput'] = None,
        max: Optional['types.SubscriptionAddonMaxAggregateInput'] = None,
        having: Optional['types.SubscriptionAddonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SubscriptionAddonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SubscriptionAddonScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SubscriptionAddonScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SubscriptionAddonGroupByOutput']:
        """Group SubscriptionAddon records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SubscriptionAddon fields to group records by
        where
            SubscriptionAddon filter to select records
        take
            Limit the maximum number of SubscriptionAddon records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SubscriptionAddonGroupByOutput]
            A list of dictionaries representing the SubscriptionAddon record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SubscriptionAddon records by updatedAt values
        # and count how many records are in each group
        results = await SubscriptionAddon.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JobSessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JobSession]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JobSession.prisma().query_raw(
            'SELECT * FROM JobSession WHERE id = $1',
            'fhdbhifae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JobSession
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JobSession.prisma().query_first(
            'SELECT * FROM JobSession WHERE sessionId = $1',
            'beeacgfcej',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JobSessionCreateInput,
        include: Optional[types.JobSessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new JobSession record.

        Parameters
        ----------
        data
            JobSession record data
        include
            Specifies which relations should be loaded on the returned JobSession model

        Returns
        -------
        prisma.models.JobSession
            The created JobSession record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JobSession record from just the required fields
        jobsession = await JobSession.prisma().create(
            data={
                # data to create a JobSession record
                'sessionId': 'bbifhdiicc',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JobSessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JobSession records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JobSession record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JobSession.prisma().create_many(
            data=[
                {
                    # data to create a JobSession record
                    'sessionId': 'bgjeccejad',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a JobSession record
                    'sessionId': 'bjagdgabbg',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JobSessionWhereUniqueInput,
        include: Optional[types.JobSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JobSession record.

        Parameters
        ----------
        where
            JobSession filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JobSession model

        Returns
        -------
        prisma.models.JobSession
            The deleted JobSession record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobsession = await JobSession.prisma().delete(
            where={
                'id': 'bjbbcffdij',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JobSessionWhereUniqueInput,
        include: Optional[types.JobSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JobSession record.

        Parameters
        ----------
        where
            JobSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JobSession model

        Returns
        -------
        prisma.models.JobSession
            The found JobSession record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobsession = await JobSession.prisma().find_unique(
            where={
                'id': 'begcgchdi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JobSessionWhereUniqueInput,
        include: Optional[types.JobSessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JobSession record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JobSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JobSession model

        Returns
        -------
        prisma.models.JobSession
            The found JobSession record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobsession = await JobSession.prisma().find_unique_or_raise(
            where={
                'id': 'bhbjceagbb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSessionWhereInput] = None,
        cursor: Optional[types.JobSessionWhereUniqueInput] = None,
        include: Optional[types.JobSessionInclude] = None,
        order: Optional[Union[types.JobSessionOrderByInput, List[types.JobSessionOrderByInput]]] = None,
        distinct: Optional[List[types.JobSessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JobSession records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JobSession records returned
        skip
            Ignore the first N results
        where
            JobSession filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobSession model
        order
            Order the returned JobSession records by any field
        distinct
            Filter JobSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JobSession]
            The list of all JobSession records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JobSession records
        jobsessions = await JobSession.prisma().find_many(take=10)

        # find the first 5 JobSession records ordered by the step field
        jobsessions = await JobSession.prisma().find_many(
            take=5,
            order={
                'step': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobSessionWhereInput] = None,
        cursor: Optional[types.JobSessionWhereUniqueInput] = None,
        include: Optional[types.JobSessionInclude] = None,
        order: Optional[Union[types.JobSessionOrderByInput, List[types.JobSessionOrderByInput]]] = None,
        distinct: Optional[List[types.JobSessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JobSession record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JobSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobSession model
        order
            Order the returned JobSession records by any field
        distinct
            Filter JobSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JobSession
            The first JobSession record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JobSession record ordered by the basicInfo field
        jobsession = await JobSession.prisma().find_first(
            skip=1,
            order={
                'basicInfo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobSessionWhereInput] = None,
        cursor: Optional[types.JobSessionWhereUniqueInput] = None,
        include: Optional[types.JobSessionInclude] = None,
        order: Optional[Union[types.JobSessionOrderByInput, List[types.JobSessionOrderByInput]]] = None,
        distinct: Optional[List[types.JobSessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JobSession record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JobSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobSession model
        order
            Order the returned JobSession records by any field
        distinct
            Filter JobSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JobSession
            The first JobSession record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JobSession record ordered by the jobDetails field
        jobsession = await JobSession.prisma().find_first_or_raise(
            skip=1,
            order={
                'jobDetails': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JobSessionUpdateInput,
        where: types.JobSessionWhereUniqueInput,
        include: Optional[types.JobSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JobSession record.

        Parameters
        ----------
        data
            JobSession record data specifying what to update
        where
            JobSession filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JobSession model

        Returns
        -------
        prisma.models.JobSession
            The updated JobSession record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        jobsession = await JobSession.prisma().update(
            where={
                'id': 'bjeifffjdg',
            },
            data={
                # data to update the JobSession record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JobSessionWhereUniqueInput,
        data: types.JobSessionUpsertInput,
        include: Optional[types.JobSessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JobSession filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JobSession model

        Returns
        -------
        prisma.models.JobSession
            The created or updated JobSession record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobsession = await JobSession.prisma().upsert(
            where={
                'id': 'bdidcfdfjd',
            },
            data={
                'create': {
                    'id': 'bdidcfdfjd',
                    'sessionId': 'bjagdgabbg',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'sessionId': 'bjagdgabbg',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JobSessionUpdateManyMutationInput,
        where: types.JobSessionWhereInput,
    ) -> int:
        """Update multiple JobSession records

        Parameters
        ----------
        data
            JobSession data to update the selected JobSession records to
        where
            Filter to select the JobSession records to update

        Returns
        -------
        int
            The total number of JobSession records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JobSession records
        total = await JobSession.prisma().update_many(
            data={
                'requirements': Json({'dfeggejja': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSessionWhereInput] = None,
        cursor: Optional[types.JobSessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JobSession records present in the database

        Parameters
        ----------
        select
            Select the JobSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JobSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JobSession.prisma().count()

        # results: prisma.types.JobSessionCountAggregateOutput
        results = await JobSession.prisma().count(
            select={
                '_all': True,
                'publishOptions': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JobSessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSessionWhereInput] = None,
        cursor: Optional[types.JobSessionWhereUniqueInput] = None,
    ) -> types.JobSessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JobSessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSessionWhereInput] = None,
        cursor: Optional[types.JobSessionWhereUniqueInput] = None,
    ) -> Union[int, types.JobSessionCountAggregateOutput]:
        """Count the number of JobSession records present in the database

        Parameters
        ----------
        select
            Select the JobSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JobSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JobSession.prisma().count()

        # results: prisma.types.JobSessionCountAggregateOutput
        results = await JobSession.prisma().count(
            select={
                '_all': True,
                'expiresAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JobSessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JobSessionWhereInput] = None
    ) -> int:
        """Delete multiple JobSession records.

        Parameters
        ----------
        where
            Optional JobSession filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JobSession records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JobSession records
        total = await JobSession.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JobSessionScalarFieldKeys'],
        *,
        where: Optional['types.JobSessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JobSessionAvgAggregateInput'] = None,
        sum: Optional['types.JobSessionSumAggregateInput'] = None,
        min: Optional['types.JobSessionMinAggregateInput'] = None,
        max: Optional['types.JobSessionMaxAggregateInput'] = None,
        having: Optional['types.JobSessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JobSessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JobSessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.JobSessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.JobSessionGroupByOutput']:
        """Group JobSession records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JobSession fields to group records by
        where
            JobSession filter to select records
        take
            Limit the maximum number of JobSession records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JobSessionGroupByOutput]
            A list of dictionaries representing the JobSession record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JobSession records by createdAt values
        # and count how many records are in each group
        results = await JobSession.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SkillSuggestionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SkillSuggestion]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SkillSuggestion.prisma().query_raw(
            'SELECT * FROM SkillSuggestion WHERE id = $1',
            'gehbgghbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SkillSuggestion
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SkillSuggestion.prisma().query_first(
            'SELECT * FROM SkillSuggestion WHERE department = $1',
            'dfhaijeie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SkillSuggestionCreateInput,
        include: Optional[types.SkillSuggestionInclude] = None
    ) -> _PrismaModelT:
        """Create a new SkillSuggestion record.

        Parameters
        ----------
        data
            SkillSuggestion record data
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model

        Returns
        -------
        prisma.models.SkillSuggestion
            The created SkillSuggestion record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SkillSuggestion record from just the required fields
        skillsuggestion = await SkillSuggestion.prisma().create(
            data={
                # data to create a SkillSuggestion record
                'department': 'gbcdjgicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SkillSuggestionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SkillSuggestion records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SkillSuggestion record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SkillSuggestion.prisma().create_many(
            data=[
                {
                    # data to create a SkillSuggestion record
                    'department': 'biaibdagac',
                },
                {
                    # data to create a SkillSuggestion record
                    'department': 'bbfbheibcd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SkillSuggestionWhereUniqueInput,
        include: Optional[types.SkillSuggestionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SkillSuggestion record.

        Parameters
        ----------
        where
            SkillSuggestion filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model

        Returns
        -------
        prisma.models.SkillSuggestion
            The deleted SkillSuggestion record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skillsuggestion = await SkillSuggestion.prisma().delete(
            where={
                'id': 'hiagajie',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SkillSuggestionWhereUniqueInput,
        include: Optional[types.SkillSuggestionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SkillSuggestion record.

        Parameters
        ----------
        where
            SkillSuggestion filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model

        Returns
        -------
        prisma.models.SkillSuggestion
            The found SkillSuggestion record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skillsuggestion = await SkillSuggestion.prisma().find_unique(
            where={
                'id': 'eeejidbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SkillSuggestionWhereUniqueInput,
        include: Optional[types.SkillSuggestionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SkillSuggestion record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SkillSuggestion filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model

        Returns
        -------
        prisma.models.SkillSuggestion
            The found SkillSuggestion record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skillsuggestion = await SkillSuggestion.prisma().find_unique_or_raise(
            where={
                'id': 'efgbahec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillSuggestionWhereInput] = None,
        cursor: Optional[types.SkillSuggestionWhereUniqueInput] = None,
        include: Optional[types.SkillSuggestionInclude] = None,
        order: Optional[Union[types.SkillSuggestionOrderByInput, List[types.SkillSuggestionOrderByInput]]] = None,
        distinct: Optional[List[types.SkillSuggestionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SkillSuggestion records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SkillSuggestion records returned
        skip
            Ignore the first N results
        where
            SkillSuggestion filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model
        order
            Order the returned SkillSuggestion records by any field
        distinct
            Filter SkillSuggestion records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SkillSuggestion]
            The list of all SkillSuggestion records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SkillSuggestion records
        skillsuggestions = await SkillSuggestion.prisma().find_many(take=10)

        # find the first 5 SkillSuggestion records ordered by the suggestions field
        skillsuggestions = await SkillSuggestion.prisma().find_many(
            take=5,
            order={
                'suggestions': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SkillSuggestionWhereInput] = None,
        cursor: Optional[types.SkillSuggestionWhereUniqueInput] = None,
        include: Optional[types.SkillSuggestionInclude] = None,
        order: Optional[Union[types.SkillSuggestionOrderByInput, List[types.SkillSuggestionOrderByInput]]] = None,
        distinct: Optional[List[types.SkillSuggestionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SkillSuggestion record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SkillSuggestion filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model
        order
            Order the returned SkillSuggestion records by any field
        distinct
            Filter SkillSuggestion records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SkillSuggestion
            The first SkillSuggestion record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SkillSuggestion record ordered by the createdAt field
        skillsuggestion = await SkillSuggestion.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SkillSuggestionWhereInput] = None,
        cursor: Optional[types.SkillSuggestionWhereUniqueInput] = None,
        include: Optional[types.SkillSuggestionInclude] = None,
        order: Optional[Union[types.SkillSuggestionOrderByInput, List[types.SkillSuggestionOrderByInput]]] = None,
        distinct: Optional[List[types.SkillSuggestionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SkillSuggestion record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SkillSuggestion filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model
        order
            Order the returned SkillSuggestion records by any field
        distinct
            Filter SkillSuggestion records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SkillSuggestion
            The first SkillSuggestion record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SkillSuggestion record ordered by the updatedAt field
        skillsuggestion = await SkillSuggestion.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SkillSuggestionUpdateInput,
        where: types.SkillSuggestionWhereUniqueInput,
        include: Optional[types.SkillSuggestionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SkillSuggestion record.

        Parameters
        ----------
        data
            SkillSuggestion record data specifying what to update
        where
            SkillSuggestion filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model

        Returns
        -------
        prisma.models.SkillSuggestion
            The updated SkillSuggestion record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        skillsuggestion = await SkillSuggestion.prisma().update(
            where={
                'id': 'hgjaiebfb',
            },
            data={
                # data to update the SkillSuggestion record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SkillSuggestionWhereUniqueInput,
        data: types.SkillSuggestionUpsertInput,
        include: Optional[types.SkillSuggestionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SkillSuggestion filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SkillSuggestion model

        Returns
        -------
        prisma.models.SkillSuggestion
            The created or updated SkillSuggestion record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skillsuggestion = await SkillSuggestion.prisma().upsert(
            where={
                'id': 'bddefjjabc',
            },
            data={
                'create': {
                    'id': 'bddefjjabc',
                    'department': 'bbfbheibcd',
                },
                'update': {
                    'department': 'bbfbheibcd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SkillSuggestionUpdateManyMutationInput,
        where: types.SkillSuggestionWhereInput,
    ) -> int:
        """Update multiple SkillSuggestion records

        Parameters
        ----------
        data
            SkillSuggestion data to update the selected SkillSuggestion records to
        where
            Filter to select the SkillSuggestion records to update

        Returns
        -------
        int
            The total number of SkillSuggestion records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SkillSuggestion records
        total = await SkillSuggestion.prisma().update_many(
            data={
                'id': 'bbbghgbadh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillSuggestionWhereInput] = None,
        cursor: Optional[types.SkillSuggestionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SkillSuggestion records present in the database

        Parameters
        ----------
        select
            Select the SkillSuggestion fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SkillSuggestion filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SkillSuggestionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SkillSuggestion.prisma().count()

        # results: prisma.types.SkillSuggestionCountAggregateOutput
        results = await SkillSuggestion.prisma().count(
            select={
                '_all': True,
                'department': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SkillSuggestionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillSuggestionWhereInput] = None,
        cursor: Optional[types.SkillSuggestionWhereUniqueInput] = None,
    ) -> types.SkillSuggestionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SkillSuggestionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillSuggestionWhereInput] = None,
        cursor: Optional[types.SkillSuggestionWhereUniqueInput] = None,
    ) -> Union[int, types.SkillSuggestionCountAggregateOutput]:
        """Count the number of SkillSuggestion records present in the database

        Parameters
        ----------
        select
            Select the SkillSuggestion fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SkillSuggestion filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SkillSuggestionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SkillSuggestion.prisma().count()

        # results: prisma.types.SkillSuggestionCountAggregateOutput
        results = await SkillSuggestion.prisma().count(
            select={
                '_all': True,
                'suggestions': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SkillSuggestionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SkillSuggestionWhereInput] = None
    ) -> int:
        """Delete multiple SkillSuggestion records.

        Parameters
        ----------
        where
            Optional SkillSuggestion filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SkillSuggestion records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SkillSuggestion records
        total = await SkillSuggestion.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SkillSuggestionScalarFieldKeys'],
        *,
        where: Optional['types.SkillSuggestionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SkillSuggestionAvgAggregateInput'] = None,
        sum: Optional['types.SkillSuggestionSumAggregateInput'] = None,
        min: Optional['types.SkillSuggestionMinAggregateInput'] = None,
        max: Optional['types.SkillSuggestionMaxAggregateInput'] = None,
        having: Optional['types.SkillSuggestionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SkillSuggestionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SkillSuggestionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SkillSuggestionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SkillSuggestionGroupByOutput']:
        """Group SkillSuggestion records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SkillSuggestion fields to group records by
        where
            SkillSuggestion filter to select records
        take
            Limit the maximum number of SkillSuggestion records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SkillSuggestionGroupByOutput]
            A list of dictionaries representing the SkillSuggestion record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SkillSuggestion records by createdAt values
        # and count how many records are in each group
        results = await SkillSuggestion.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JobActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Job]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Job.prisma().query_raw(
            'SELECT * FROM Job WHERE id = $1',
            'bbhcgagaic',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Job
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Job.prisma().query_first(
            'SELECT * FROM Job WHERE title = $1',
            'ddaabegbb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JobCreateInput,
        include: Optional[types.JobInclude] = None
    ) -> _PrismaModelT:
        """Create a new Job record.

        Parameters
        ----------
        data
            Job record data
        include
            Specifies which relations should be loaded on the returned Job model

        Returns
        -------
        prisma.models.Job
            The created Job record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Job record from just the required fields
        job = await Job.prisma().create(
            data={
                # data to create a Job record
                'title': 'bhgibfgbbc',
                'department': 'hbgcihef',
                'location': 'ffhgghde',
                'employmentType': enums.EmploymentType.FULL_TIME,
                'salaryMin': 812032495,
                'salaryMax': 1323562236,
                'salaryPeriod': enums.SalaryPeriod.yearly,
                'description': 'edhjgdfh',
                'languages': Json({'bdeffdadda': True}),
                'userId': 'bjgfdihchf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JobCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Job records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Job record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Job.prisma().create_many(
            data=[
                {
                    # data to create a Job record
                    'title': 'iaeihdeei',
                    'department': 'bfggejgfbd',
                    'location': 'ifaaaedja',
                    'employmentType': enums.EmploymentType.FULL_TIME,
                    'salaryMin': 2109399015,
                    'salaryMax': 1282664340,
                    'salaryPeriod': enums.SalaryPeriod.yearly,
                    'description': 'cebcdadjh',
                    'languages': Json({'ehfigdgac': True}),
                    'userId': 'bhbgccijjf',
                },
                {
                    # data to create a Job record
                    'title': 'bigjhdgbjc',
                    'department': 'bfifdebhfd',
                    'location': 'cjchbjde',
                    'employmentType': enums.EmploymentType.FULL_TIME,
                    'salaryMin': 1588192479,
                    'salaryMax': 898405676,
                    'salaryPeriod': enums.SalaryPeriod.yearly,
                    'description': 'hhhegahcf',
                    'languages': Json({'edhijefdi': True}),
                    'userId': 'djddecjhb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JobWhereUniqueInput,
        include: Optional[types.JobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Job record.

        Parameters
        ----------
        where
            Job filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Job model

        Returns
        -------
        prisma.models.Job
            The deleted Job record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = await Job.prisma().delete(
            where={
                'id': 'bgdicjhie',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JobWhereUniqueInput,
        include: Optional[types.JobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Job record.

        Parameters
        ----------
        where
            Job filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Job model

        Returns
        -------
        prisma.models.Job
            The found Job record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = await Job.prisma().find_unique(
            where={
                'id': 'ceibfcgij',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JobWhereUniqueInput,
        include: Optional[types.JobInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Job record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Job filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Job model

        Returns
        -------
        prisma.models.Job
            The found Job record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = await Job.prisma().find_unique_or_raise(
            where={
                'id': 'debhbfada',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobWhereInput] = None,
        cursor: Optional[types.JobWhereUniqueInput] = None,
        include: Optional[types.JobInclude] = None,
        order: Optional[Union[types.JobOrderByInput, List[types.JobOrderByInput]]] = None,
        distinct: Optional[List[types.JobScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Job records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Job records returned
        skip
            Ignore the first N results
        where
            Job filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Job model
        order
            Order the returned Job records by any field
        distinct
            Filter Job records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Job]
            The list of all Job records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Job records
        jobs = await Job.prisma().find_many(take=10)

        # find the first 5 Job records ordered by the department field
        jobs = await Job.prisma().find_many(
            take=5,
            order={
                'department': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobWhereInput] = None,
        cursor: Optional[types.JobWhereUniqueInput] = None,
        include: Optional[types.JobInclude] = None,
        order: Optional[Union[types.JobOrderByInput, List[types.JobOrderByInput]]] = None,
        distinct: Optional[List[types.JobScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Job record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Job filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Job model
        order
            Order the returned Job records by any field
        distinct
            Filter Job records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Job
            The first Job record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Job record ordered by the location field
        job = await Job.prisma().find_first(
            skip=1,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobWhereInput] = None,
        cursor: Optional[types.JobWhereUniqueInput] = None,
        include: Optional[types.JobInclude] = None,
        order: Optional[Union[types.JobOrderByInput, List[types.JobOrderByInput]]] = None,
        distinct: Optional[List[types.JobScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Job record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Job filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Job model
        order
            Order the returned Job records by any field
        distinct
            Filter Job records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Job
            The first Job record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Job record ordered by the employmentType field
        job = await Job.prisma().find_first_or_raise(
            skip=1,
            order={
                'employmentType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JobUpdateInput,
        where: types.JobWhereUniqueInput,
        include: Optional[types.JobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Job record.

        Parameters
        ----------
        data
            Job record data specifying what to update
        where
            Job filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Job model

        Returns
        -------
        prisma.models.Job
            The updated Job record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        job = await Job.prisma().update(
            where={
                'id': 'bgjchggecd',
            },
            data={
                # data to update the Job record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JobWhereUniqueInput,
        data: types.JobUpsertInput,
        include: Optional[types.JobInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Job filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Job model

        Returns
        -------
        prisma.models.Job
            The created or updated Job record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = await Job.prisma().upsert(
            where={
                'id': 'igggcfjg',
            },
            data={
                'create': {
                    'id': 'igggcfjg',
                    'title': 'bigjhdgbjc',
                    'department': 'bfifdebhfd',
                    'location': 'cjchbjde',
                    'employmentType': enums.EmploymentType.FULL_TIME,
                    'salaryMin': 1588192479,
                    'salaryMax': 898405676,
                    'salaryPeriod': enums.SalaryPeriod.yearly,
                    'description': 'hhhegahcf',
                    'languages': Json({'edhijefdi': True}),
                    'userId': 'djddecjhb',
                },
                'update': {
                    'title': 'bigjhdgbjc',
                    'department': 'bfifdebhfd',
                    'location': 'cjchbjde',
                    'employmentType': enums.EmploymentType.FULL_TIME,
                    'salaryMin': 1588192479,
                    'salaryMax': 898405676,
                    'salaryPeriod': enums.SalaryPeriod.yearly,
                    'description': 'hhhegahcf',
                    'languages': Json({'edhijefdi': True}),
                    'userId': 'djddecjhb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JobUpdateManyMutationInput,
        where: types.JobWhereInput,
    ) -> int:
        """Update multiple Job records

        Parameters
        ----------
        data
            Job data to update the selected Job records to
        where
            Filter to select the Job records to update

        Returns
        -------
        int
            The total number of Job records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Job records
        total = await Job.prisma().update_many(
            data={
                'salaryMin': 1697895597
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobWhereInput] = None,
        cursor: Optional[types.JobWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Job records present in the database

        Parameters
        ----------
        select
            Select the Job fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Job filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Job.prisma().count()

        # results: prisma.types.JobCountAggregateOutput
        results = await Job.prisma().count(
            select={
                '_all': True,
                'salaryMax': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JobCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobWhereInput] = None,
        cursor: Optional[types.JobWhereUniqueInput] = None,
    ) -> types.JobCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JobCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobWhereInput] = None,
        cursor: Optional[types.JobWhereUniqueInput] = None,
    ) -> Union[int, types.JobCountAggregateOutput]:
        """Count the number of Job records present in the database

        Parameters
        ----------
        select
            Select the Job fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Job filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Job.prisma().count()

        # results: prisma.types.JobCountAggregateOutput
        results = await Job.prisma().count(
            select={
                '_all': True,
                'salaryPeriod': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JobCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JobWhereInput] = None
    ) -> int:
        """Delete multiple Job records.

        Parameters
        ----------
        where
            Optional Job filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Job records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Job records
        total = await Job.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JobScalarFieldKeys'],
        *,
        where: Optional['types.JobWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JobAvgAggregateInput'] = None,
        sum: Optional['types.JobSumAggregateInput'] = None,
        min: Optional['types.JobMinAggregateInput'] = None,
        max: Optional['types.JobMaxAggregateInput'] = None,
        having: Optional['types.JobScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JobCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JobScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.JobScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.JobGroupByOutput']:
        """Group Job records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Job fields to group records by
        where
            Job filter to select records
        take
            Limit the maximum number of Job records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JobGroupByOutput]
            A list of dictionaries representing the Job record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Job records by description values
        # and count how many records are in each group
        results = await Job.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CandidateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Candidate]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Candidate.prisma().query_raw(
            'SELECT * FROM Candidate WHERE id = $1',
            'bcigdhache',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Candidate
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Candidate.prisma().query_first(
            'SELECT * FROM Candidate WHERE email = $1',
            'igefhgdhb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CandidateCreateInput,
        include: Optional[types.CandidateInclude] = None
    ) -> _PrismaModelT:
        """Create a new Candidate record.

        Parameters
        ----------
        data
            Candidate record data
        include
            Specifies which relations should be loaded on the returned Candidate model

        Returns
        -------
        prisma.models.Candidate
            The created Candidate record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Candidate record from just the required fields
        candidate = await Candidate.prisma().create(
            data={
                # data to create a Candidate record
                'email': 'ejbiifbae',
                'name': 'djcfgedjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CandidateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Candidate records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Candidate record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Candidate.prisma().create_many(
            data=[
                {
                    # data to create a Candidate record
                    'email': 'bdbjcdegag',
                    'name': 'hbchfebch',
                },
                {
                    # data to create a Candidate record
                    'email': 'bcjjffegfc',
                    'name': 'cahaeaicjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CandidateWhereUniqueInput,
        include: Optional[types.CandidateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Candidate record.

        Parameters
        ----------
        where
            Candidate filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Candidate model

        Returns
        -------
        prisma.models.Candidate
            The deleted Candidate record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        candidate = await Candidate.prisma().delete(
            where={
                'id': 'ibbjaacbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CandidateWhereUniqueInput,
        include: Optional[types.CandidateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Candidate record.

        Parameters
        ----------
        where
            Candidate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Candidate model

        Returns
        -------
        prisma.models.Candidate
            The found Candidate record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        candidate = await Candidate.prisma().find_unique(
            where={
                'id': 'djgacbcch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CandidateWhereUniqueInput,
        include: Optional[types.CandidateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Candidate record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Candidate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Candidate model

        Returns
        -------
        prisma.models.Candidate
            The found Candidate record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        candidate = await Candidate.prisma().find_unique_or_raise(
            where={
                'id': 'geeeegace',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CandidateWhereInput] = None,
        cursor: Optional[types.CandidateWhereUniqueInput] = None,
        include: Optional[types.CandidateInclude] = None,
        order: Optional[Union[types.CandidateOrderByInput, List[types.CandidateOrderByInput]]] = None,
        distinct: Optional[List[types.CandidateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Candidate records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Candidate records returned
        skip
            Ignore the first N results
        where
            Candidate filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Candidate model
        order
            Order the returned Candidate records by any field
        distinct
            Filter Candidate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Candidate]
            The list of all Candidate records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Candidate records
        candidates = await Candidate.prisma().find_many(take=10)

        # find the first 5 Candidate records ordered by the name field
        candidates = await Candidate.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CandidateWhereInput] = None,
        cursor: Optional[types.CandidateWhereUniqueInput] = None,
        include: Optional[types.CandidateInclude] = None,
        order: Optional[Union[types.CandidateOrderByInput, List[types.CandidateOrderByInput]]] = None,
        distinct: Optional[List[types.CandidateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Candidate record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Candidate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Candidate model
        order
            Order the returned Candidate records by any field
        distinct
            Filter Candidate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Candidate
            The first Candidate record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Candidate record ordered by the phone field
        candidate = await Candidate.prisma().find_first(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CandidateWhereInput] = None,
        cursor: Optional[types.CandidateWhereUniqueInput] = None,
        include: Optional[types.CandidateInclude] = None,
        order: Optional[Union[types.CandidateOrderByInput, List[types.CandidateOrderByInput]]] = None,
        distinct: Optional[List[types.CandidateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Candidate record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Candidate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Candidate model
        order
            Order the returned Candidate records by any field
        distinct
            Filter Candidate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Candidate
            The first Candidate record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Candidate record ordered by the address field
        candidate = await Candidate.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CandidateUpdateInput,
        where: types.CandidateWhereUniqueInput,
        include: Optional[types.CandidateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Candidate record.

        Parameters
        ----------
        data
            Candidate record data specifying what to update
        where
            Candidate filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Candidate model

        Returns
        -------
        prisma.models.Candidate
            The updated Candidate record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        candidate = await Candidate.prisma().update(
            where={
                'id': 'bbgdigchd',
            },
            data={
                # data to update the Candidate record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CandidateWhereUniqueInput,
        data: types.CandidateUpsertInput,
        include: Optional[types.CandidateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Candidate filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Candidate model

        Returns
        -------
        prisma.models.Candidate
            The created or updated Candidate record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        candidate = await Candidate.prisma().upsert(
            where={
                'id': 'dajcifgdi',
            },
            data={
                'create': {
                    'id': 'dajcifgdi',
                    'email': 'bcjjffegfc',
                    'name': 'cahaeaicjd',
                },
                'update': {
                    'email': 'bcjjffegfc',
                    'name': 'cahaeaicjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CandidateUpdateManyMutationInput,
        where: types.CandidateWhereInput,
    ) -> int:
        """Update multiple Candidate records

        Parameters
        ----------
        data
            Candidate data to update the selected Candidate records to
        where
            Filter to select the Candidate records to update

        Returns
        -------
        int
            The total number of Candidate records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Candidate records
        total = await Candidate.prisma().update_many(
            data={
                'location': 'ccedhdbj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CandidateWhereInput] = None,
        cursor: Optional[types.CandidateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Candidate records present in the database

        Parameters
        ----------
        select
            Select the Candidate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Candidate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CandidateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Candidate.prisma().count()

        # results: prisma.types.CandidateCountAggregateOutput
        results = await Candidate.prisma().count(
            select={
                '_all': True,
                'personalInfo': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CandidateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CandidateWhereInput] = None,
        cursor: Optional[types.CandidateWhereUniqueInput] = None,
    ) -> types.CandidateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CandidateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CandidateWhereInput] = None,
        cursor: Optional[types.CandidateWhereUniqueInput] = None,
    ) -> Union[int, types.CandidateCountAggregateOutput]:
        """Count the number of Candidate records present in the database

        Parameters
        ----------
        select
            Select the Candidate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Candidate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CandidateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Candidate.prisma().count()

        # results: prisma.types.CandidateCountAggregateOutput
        results = await Candidate.prisma().count(
            select={
                '_all': True,
                'summary': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CandidateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CandidateWhereInput] = None
    ) -> int:
        """Delete multiple Candidate records.

        Parameters
        ----------
        where
            Optional Candidate filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Candidate records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Candidate records
        total = await Candidate.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CandidateScalarFieldKeys'],
        *,
        where: Optional['types.CandidateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CandidateAvgAggregateInput'] = None,
        sum: Optional['types.CandidateSumAggregateInput'] = None,
        min: Optional['types.CandidateMinAggregateInput'] = None,
        max: Optional['types.CandidateMaxAggregateInput'] = None,
        having: Optional['types.CandidateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CandidateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CandidateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CandidateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CandidateGroupByOutput']:
        """Group Candidate records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Candidate fields to group records by
        where
            Candidate filter to select records
        take
            Limit the maximum number of Candidate records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CandidateGroupByOutput]
            A list of dictionaries representing the Candidate record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Candidate records by education values
        # and count how many records are in each group
        results = await Candidate.prisma().group_by(
            ['education'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ApplicationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Application]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Application.prisma().query_raw(
            'SELECT * FROM Application WHERE id = $1',
            'bjaabjjjce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Application
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Application.prisma().query_first(
            'SELECT * FROM Application WHERE jobId = $1',
            'cafhdcdcjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ApplicationCreateInput,
        include: Optional[types.ApplicationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Application record.

        Parameters
        ----------
        data
            Application record data
        include
            Specifies which relations should be loaded on the returned Application model

        Returns
        -------
        prisma.models.Application
            The created Application record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Application record from just the required fields
        application = await Application.prisma().create(
            data={
                # data to create a Application record
                'jobId': 'bdeebbhbdi',
                'candidateId': 'cafcbdchah',
                'userId': 'bdffbehbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ApplicationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Application records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Application record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Application.prisma().create_many(
            data=[
                {
                    # data to create a Application record
                    'jobId': 'ieahjgeb',
                    'candidateId': 'hfeeddceg',
                    'userId': 'dbecgbbid',
                },
                {
                    # data to create a Application record
                    'jobId': 'cchghigae',
                    'candidateId': 'ecdjjjhab',
                    'userId': 'biachfede',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ApplicationWhereUniqueInput,
        include: Optional[types.ApplicationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Application record.

        Parameters
        ----------
        where
            Application filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Application model

        Returns
        -------
        prisma.models.Application
            The deleted Application record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        application = await Application.prisma().delete(
            where={
                'id': 'fhgaibff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ApplicationWhereUniqueInput,
        include: Optional[types.ApplicationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Application record.

        Parameters
        ----------
        where
            Application filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Application model

        Returns
        -------
        prisma.models.Application
            The found Application record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        application = await Application.prisma().find_unique(
            where={
                'id': 'cadajbcbca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ApplicationWhereUniqueInput,
        include: Optional[types.ApplicationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Application record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Application filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Application model

        Returns
        -------
        prisma.models.Application
            The found Application record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        application = await Application.prisma().find_unique_or_raise(
            where={
                'id': 'bjheigfcdd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApplicationWhereInput] = None,
        cursor: Optional[types.ApplicationWhereUniqueInput] = None,
        include: Optional[types.ApplicationInclude] = None,
        order: Optional[Union[types.ApplicationOrderByInput, List[types.ApplicationOrderByInput]]] = None,
        distinct: Optional[List[types.ApplicationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Application records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Application records returned
        skip
            Ignore the first N results
        where
            Application filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Application model
        order
            Order the returned Application records by any field
        distinct
            Filter Application records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Application]
            The list of all Application records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Application records
        applications = await Application.prisma().find_many(take=10)

        # find the first 5 Application records ordered by the candidateId field
        applications = await Application.prisma().find_many(
            take=5,
            order={
                'candidateId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ApplicationWhereInput] = None,
        cursor: Optional[types.ApplicationWhereUniqueInput] = None,
        include: Optional[types.ApplicationInclude] = None,
        order: Optional[Union[types.ApplicationOrderByInput, List[types.ApplicationOrderByInput]]] = None,
        distinct: Optional[List[types.ApplicationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Application record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Application filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Application model
        order
            Order the returned Application records by any field
        distinct
            Filter Application records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Application
            The first Application record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Application record ordered by the coverLetter field
        application = await Application.prisma().find_first(
            skip=1,
            order={
                'coverLetter': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ApplicationWhereInput] = None,
        cursor: Optional[types.ApplicationWhereUniqueInput] = None,
        include: Optional[types.ApplicationInclude] = None,
        order: Optional[Union[types.ApplicationOrderByInput, List[types.ApplicationOrderByInput]]] = None,
        distinct: Optional[List[types.ApplicationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Application record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Application filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Application model
        order
            Order the returned Application records by any field
        distinct
            Filter Application records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Application
            The first Application record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Application record ordered by the status field
        application = await Application.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ApplicationUpdateInput,
        where: types.ApplicationWhereUniqueInput,
        include: Optional[types.ApplicationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Application record.

        Parameters
        ----------
        data
            Application record data specifying what to update
        where
            Application filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Application model

        Returns
        -------
        prisma.models.Application
            The updated Application record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        application = await Application.prisma().update(
            where={
                'id': 'bjejigcdcg',
            },
            data={
                # data to update the Application record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ApplicationWhereUniqueInput,
        data: types.ApplicationUpsertInput,
        include: Optional[types.ApplicationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Application filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Application model

        Returns
        -------
        prisma.models.Application
            The created or updated Application record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        application = await Application.prisma().upsert(
            where={
                'id': 'bifiiibcah',
            },
            data={
                'create': {
                    'id': 'bifiiibcah',
                    'jobId': 'cchghigae',
                    'candidateId': 'ecdjjjhab',
                    'userId': 'biachfede',
                },
                'update': {
                    'jobId': 'cchghigae',
                    'candidateId': 'ecdjjjhab',
                    'userId': 'biachfede',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ApplicationUpdateManyMutationInput,
        where: types.ApplicationWhereInput,
    ) -> int:
        """Update multiple Application records

        Parameters
        ----------
        data
            Application data to update the selected Application records to
        where
            Filter to select the Application records to update

        Returns
        -------
        int
            The total number of Application records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Application records
        total = await Application.prisma().update_many(
            data={
                'matchScore': 319819300
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApplicationWhereInput] = None,
        cursor: Optional[types.ApplicationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Application records present in the database

        Parameters
        ----------
        select
            Select the Application fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Application filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ApplicationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Application.prisma().count()

        # results: prisma.types.ApplicationCountAggregateOutput
        results = await Application.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ApplicationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApplicationWhereInput] = None,
        cursor: Optional[types.ApplicationWhereUniqueInput] = None,
    ) -> types.ApplicationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ApplicationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApplicationWhereInput] = None,
        cursor: Optional[types.ApplicationWhereUniqueInput] = None,
    ) -> Union[int, types.ApplicationCountAggregateOutput]:
        """Count the number of Application records present in the database

        Parameters
        ----------
        select
            Select the Application fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Application filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ApplicationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Application.prisma().count()

        # results: prisma.types.ApplicationCountAggregateOutput
        results = await Application.prisma().count(
            select={
                '_all': True,
                'joinToken': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ApplicationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ApplicationWhereInput] = None
    ) -> int:
        """Delete multiple Application records.

        Parameters
        ----------
        where
            Optional Application filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Application records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Application records
        total = await Application.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ApplicationScalarFieldKeys'],
        *,
        where: Optional['types.ApplicationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ApplicationAvgAggregateInput'] = None,
        sum: Optional['types.ApplicationSumAggregateInput'] = None,
        min: Optional['types.ApplicationMinAggregateInput'] = None,
        max: Optional['types.ApplicationMaxAggregateInput'] = None,
        having: Optional['types.ApplicationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ApplicationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ApplicationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ApplicationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ApplicationGroupByOutput']:
        """Group Application records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Application fields to group records by
        where
            Application filter to select records
        take
            Limit the maximum number of Application records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ApplicationGroupByOutput]
            A list of dictionaries representing the Application record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Application records by tokenExpiry values
        # and count how many records are in each group
        results = await Application.prisma().group_by(
            ['tokenExpiry'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InterviewActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Interview]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Interview.prisma().query_raw(
            'SELECT * FROM Interview WHERE id = $1',
            'dgijbdiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Interview
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Interview.prisma().query_first(
            'SELECT * FROM Interview WHERE candidateId = $1',
            'begfaigba',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InterviewCreateInput,
        include: Optional[types.InterviewInclude] = None
    ) -> _PrismaModelT:
        """Create a new Interview record.

        Parameters
        ----------
        data
            Interview record data
        include
            Specifies which relations should be loaded on the returned Interview model

        Returns
        -------
        prisma.models.Interview
            The created Interview record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Interview record from just the required fields
        interview = await Interview.prisma().create(
            data={
                # data to create a Interview record
                'candidateId': 'bdjiafcgjb',
                'applicationId': 'bficecgcfg',
                'scheduledById': 'cbjjeedcj',
                'jobId': 'dedgbbhja',
                'type': enums.InterviewType.PHONE,
                'scheduledAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InterviewCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Interview records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Interview record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Interview.prisma().create_many(
            data=[
                {
                    # data to create a Interview record
                    'candidateId': 'cabiahchj',
                    'applicationId': 'cgbeccfce',
                    'scheduledById': 'fcjcagef',
                    'jobId': 'bgdhaeacic',
                    'type': enums.InterviewType.PHONE,
                    'scheduledAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Interview record
                    'candidateId': 'caffafcheh',
                    'applicationId': 'fjjbegge',
                    'scheduledById': 'bdiifhbieb',
                    'jobId': 'cdcaejhgg',
                    'type': enums.InterviewType.PHONE,
                    'scheduledAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InterviewWhereUniqueInput,
        include: Optional[types.InterviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Interview record.

        Parameters
        ----------
        where
            Interview filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Interview model

        Returns
        -------
        prisma.models.Interview
            The deleted Interview record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interview = await Interview.prisma().delete(
            where={
                'id': 'jbijgfbfj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InterviewWhereUniqueInput,
        include: Optional[types.InterviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Interview record.

        Parameters
        ----------
        where
            Interview filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Interview model

        Returns
        -------
        prisma.models.Interview
            The found Interview record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interview = await Interview.prisma().find_unique(
            where={
                'id': 'ggfbeddia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InterviewWhereUniqueInput,
        include: Optional[types.InterviewInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Interview record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Interview filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Interview model

        Returns
        -------
        prisma.models.Interview
            The found Interview record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interview = await Interview.prisma().find_unique_or_raise(
            where={
                'id': 'djjejdaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewWhereInput] = None,
        cursor: Optional[types.InterviewWhereUniqueInput] = None,
        include: Optional[types.InterviewInclude] = None,
        order: Optional[Union[types.InterviewOrderByInput, List[types.InterviewOrderByInput]]] = None,
        distinct: Optional[List[types.InterviewScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Interview records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Interview records returned
        skip
            Ignore the first N results
        where
            Interview filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Interview model
        order
            Order the returned Interview records by any field
        distinct
            Filter Interview records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Interview]
            The list of all Interview records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Interview records
        interviews = await Interview.prisma().find_many(take=10)

        # find the first 5 Interview records ordered by the applicationId field
        interviews = await Interview.prisma().find_many(
            take=5,
            order={
                'applicationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InterviewWhereInput] = None,
        cursor: Optional[types.InterviewWhereUniqueInput] = None,
        include: Optional[types.InterviewInclude] = None,
        order: Optional[Union[types.InterviewOrderByInput, List[types.InterviewOrderByInput]]] = None,
        distinct: Optional[List[types.InterviewScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Interview record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Interview filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Interview model
        order
            Order the returned Interview records by any field
        distinct
            Filter Interview records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Interview
            The first Interview record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Interview record ordered by the scheduledById field
        interview = await Interview.prisma().find_first(
            skip=1,
            order={
                'scheduledById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InterviewWhereInput] = None,
        cursor: Optional[types.InterviewWhereUniqueInput] = None,
        include: Optional[types.InterviewInclude] = None,
        order: Optional[Union[types.InterviewOrderByInput, List[types.InterviewOrderByInput]]] = None,
        distinct: Optional[List[types.InterviewScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Interview record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Interview filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Interview model
        order
            Order the returned Interview records by any field
        distinct
            Filter Interview records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Interview
            The first Interview record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Interview record ordered by the jobId field
        interview = await Interview.prisma().find_first_or_raise(
            skip=1,
            order={
                'jobId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InterviewUpdateInput,
        where: types.InterviewWhereUniqueInput,
        include: Optional[types.InterviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Interview record.

        Parameters
        ----------
        data
            Interview record data specifying what to update
        where
            Interview filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Interview model

        Returns
        -------
        prisma.models.Interview
            The updated Interview record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        interview = await Interview.prisma().update(
            where={
                'id': 'bjabbfceji',
            },
            data={
                # data to update the Interview record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InterviewWhereUniqueInput,
        data: types.InterviewUpsertInput,
        include: Optional[types.InterviewInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Interview filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Interview model

        Returns
        -------
        prisma.models.Interview
            The created or updated Interview record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interview = await Interview.prisma().upsert(
            where={
                'id': 'bgchfbjibb',
            },
            data={
                'create': {
                    'id': 'bgchfbjibb',
                    'candidateId': 'caffafcheh',
                    'applicationId': 'fjjbegge',
                    'scheduledById': 'bdiifhbieb',
                    'jobId': 'cdcaejhgg',
                    'type': enums.InterviewType.PHONE,
                    'scheduledAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'candidateId': 'caffafcheh',
                    'applicationId': 'fjjbegge',
                    'scheduledById': 'bdiifhbieb',
                    'jobId': 'cdcaejhgg',
                    'type': enums.InterviewType.PHONE,
                    'scheduledAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InterviewUpdateManyMutationInput,
        where: types.InterviewWhereInput,
    ) -> int:
        """Update multiple Interview records

        Parameters
        ----------
        data
            Interview data to update the selected Interview records to
        where
            Filter to select the Interview records to update

        Returns
        -------
        int
            The total number of Interview records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Interview records
        total = await Interview.prisma().update_many(
            data={
                'type': enums.InterviewType.PHONE
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewWhereInput] = None,
        cursor: Optional[types.InterviewWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Interview records present in the database

        Parameters
        ----------
        select
            Select the Interview fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Interview filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InterviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Interview.prisma().count()

        # results: prisma.types.InterviewCountAggregateOutput
        results = await Interview.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InterviewCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewWhereInput] = None,
        cursor: Optional[types.InterviewWhereUniqueInput] = None,
    ) -> types.InterviewCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InterviewCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewWhereInput] = None,
        cursor: Optional[types.InterviewWhereUniqueInput] = None,
    ) -> Union[int, types.InterviewCountAggregateOutput]:
        """Count the number of Interview records present in the database

        Parameters
        ----------
        select
            Select the Interview fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Interview filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InterviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Interview.prisma().count()

        # results: prisma.types.InterviewCountAggregateOutput
        results = await Interview.prisma().count(
            select={
                '_all': True,
                'scheduledAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InterviewCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InterviewWhereInput] = None
    ) -> int:
        """Delete multiple Interview records.

        Parameters
        ----------
        where
            Optional Interview filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Interview records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Interview records
        total = await Interview.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InterviewScalarFieldKeys'],
        *,
        where: Optional['types.InterviewWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InterviewAvgAggregateInput'] = None,
        sum: Optional['types.InterviewSumAggregateInput'] = None,
        min: Optional['types.InterviewMinAggregateInput'] = None,
        max: Optional['types.InterviewMaxAggregateInput'] = None,
        having: Optional['types.InterviewScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InterviewCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InterviewScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InterviewScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InterviewGroupByOutput']:
        """Group Interview records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Interview fields to group records by
        where
            Interview filter to select records
        take
            Limit the maximum number of Interview records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InterviewGroupByOutput]
            A list of dictionaries representing the Interview record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Interview records by duration values
        # and count how many records are in each group
        results = await Interview.prisma().group_by(
            ['duration'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InterviewResultActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.InterviewResult]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await InterviewResult.prisma().query_raw(
            'SELECT * FROM InterviewResult WHERE id = $1',
            'bajecchdjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.InterviewResult
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await InterviewResult.prisma().query_first(
            'SELECT * FROM InterviewResult WHERE interviewId = $1',
            'dfgacajif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InterviewResultCreateInput,
        include: Optional[types.InterviewResultInclude] = None
    ) -> _PrismaModelT:
        """Create a new InterviewResult record.

        Parameters
        ----------
        data
            InterviewResult record data
        include
            Specifies which relations should be loaded on the returned InterviewResult model

        Returns
        -------
        prisma.models.InterviewResult
            The created InterviewResult record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a InterviewResult record from just the required fields
        interviewresult = await InterviewResult.prisma().create(
            data={
                # data to create a InterviewResult record
                'interviewId': 'bgdiddfadi',
                'candidateId': 'bijbfghhhf',
                'applicationId': 'bahchhihdc',
                'jobId': 'bihjdcibib',
                'evaluatedCount': 1577911370,
                'totalQuestions': 504729531,
                'averageFactualAccuracy': 110845144.130026,
                'averageCompleteness': 1881086742.108235,
                'averageRelevance': 1456828036.212470,
                'averageCoherence': 1298780834.106589,
                'averageScore': 1266478832.192302,
                'passStatus': 'jfieeahi',
                'summaryResult': 'bijfjbddfj',
                'knowledgeLevel': 'cdcdjdcee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InterviewResultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple InterviewResult records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of InterviewResult record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await InterviewResult.prisma().create_many(
            data=[
                {
                    # data to create a InterviewResult record
                    'interviewId': 'bbbgjdbgcb',
                    'candidateId': 'bcedacgecg',
                    'applicationId': 'cbdffjeh',
                    'jobId': 'idbcdhbci',
                    'evaluatedCount': 1024647073,
                    'totalQuestions': 414348742,
                    'averageFactualAccuracy': 1090693511.166431,
                    'averageCompleteness': 761058525.149842,
                    'averageRelevance': 1960204067.144087,
                    'averageCoherence': 1515643353.91674,
                    'averageScore': 44909183.45732,
                    'passStatus': 'cadejecgbd',
                    'summaryResult': 'bahjhjjhcc',
                    'knowledgeLevel': 'ebhbhbdff',
                },
                {
                    # data to create a InterviewResult record
                    'interviewId': 'bdiefcdfhg',
                    'candidateId': 'cheifeghd',
                    'applicationId': 'fgijheefe',
                    'jobId': 'hcbgbhfch',
                    'evaluatedCount': 1511161572,
                    'totalQuestions': 81899341,
                    'averageFactualAccuracy': 2047822338.162079,
                    'averageCompleteness': 1877648720.136150,
                    'averageRelevance': 522978382.136536,
                    'averageCoherence': 1826408060.50977,
                    'averageScore': 1548228442.72846,
                    'passStatus': 'bahifjfga',
                    'summaryResult': 'baebfehjaf',
                    'knowledgeLevel': 'bjchdacjfa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InterviewResultWhereUniqueInput,
        include: Optional[types.InterviewResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single InterviewResult record.

        Parameters
        ----------
        where
            InterviewResult filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned InterviewResult model

        Returns
        -------
        prisma.models.InterviewResult
            The deleted InterviewResult record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interviewresult = await InterviewResult.prisma().delete(
            where={
                'id': 'fcadcaihb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InterviewResultWhereUniqueInput,
        include: Optional[types.InterviewResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique InterviewResult record.

        Parameters
        ----------
        where
            InterviewResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InterviewResult model

        Returns
        -------
        prisma.models.InterviewResult
            The found InterviewResult record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interviewresult = await InterviewResult.prisma().find_unique(
            where={
                'id': 'bbdcibggga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InterviewResultWhereUniqueInput,
        include: Optional[types.InterviewResultInclude] = None
    ) -> _PrismaModelT:
        """Find a unique InterviewResult record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            InterviewResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InterviewResult model

        Returns
        -------
        prisma.models.InterviewResult
            The found InterviewResult record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interviewresult = await InterviewResult.prisma().find_unique_or_raise(
            where={
                'id': 'bagbibfheb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewResultWhereInput] = None,
        cursor: Optional[types.InterviewResultWhereUniqueInput] = None,
        include: Optional[types.InterviewResultInclude] = None,
        order: Optional[Union[types.InterviewResultOrderByInput, List[types.InterviewResultOrderByInput]]] = None,
        distinct: Optional[List[types.InterviewResultScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple InterviewResult records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of InterviewResult records returned
        skip
            Ignore the first N results
        where
            InterviewResult filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InterviewResult model
        order
            Order the returned InterviewResult records by any field
        distinct
            Filter InterviewResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.InterviewResult]
            The list of all InterviewResult records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 InterviewResult records
        interviewresults = await InterviewResult.prisma().find_many(take=10)

        # find the first 5 InterviewResult records ordered by the candidateId field
        interviewresults = await InterviewResult.prisma().find_many(
            take=5,
            order={
                'candidateId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InterviewResultWhereInput] = None,
        cursor: Optional[types.InterviewResultWhereUniqueInput] = None,
        include: Optional[types.InterviewResultInclude] = None,
        order: Optional[Union[types.InterviewResultOrderByInput, List[types.InterviewResultOrderByInput]]] = None,
        distinct: Optional[List[types.InterviewResultScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single InterviewResult record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InterviewResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InterviewResult model
        order
            Order the returned InterviewResult records by any field
        distinct
            Filter InterviewResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InterviewResult
            The first InterviewResult record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InterviewResult record ordered by the applicationId field
        interviewresult = await InterviewResult.prisma().find_first(
            skip=1,
            order={
                'applicationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InterviewResultWhereInput] = None,
        cursor: Optional[types.InterviewResultWhereUniqueInput] = None,
        include: Optional[types.InterviewResultInclude] = None,
        order: Optional[Union[types.InterviewResultOrderByInput, List[types.InterviewResultOrderByInput]]] = None,
        distinct: Optional[List[types.InterviewResultScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single InterviewResult record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InterviewResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InterviewResult model
        order
            Order the returned InterviewResult records by any field
        distinct
            Filter InterviewResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InterviewResult
            The first InterviewResult record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InterviewResult record ordered by the jobId field
        interviewresult = await InterviewResult.prisma().find_first_or_raise(
            skip=1,
            order={
                'jobId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InterviewResultUpdateInput,
        where: types.InterviewResultWhereUniqueInput,
        include: Optional[types.InterviewResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single InterviewResult record.

        Parameters
        ----------
        data
            InterviewResult record data specifying what to update
        where
            InterviewResult filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned InterviewResult model

        Returns
        -------
        prisma.models.InterviewResult
            The updated InterviewResult record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        interviewresult = await InterviewResult.prisma().update(
            where={
                'id': 'bidgcabjag',
            },
            data={
                # data to update the InterviewResult record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InterviewResultWhereUniqueInput,
        data: types.InterviewResultUpsertInput,
        include: Optional[types.InterviewResultInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            InterviewResult filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned InterviewResult model

        Returns
        -------
        prisma.models.InterviewResult
            The created or updated InterviewResult record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        interviewresult = await InterviewResult.prisma().upsert(
            where={
                'id': 'hechjdjih',
            },
            data={
                'create': {
                    'id': 'hechjdjih',
                    'interviewId': 'bdiefcdfhg',
                    'candidateId': 'cheifeghd',
                    'applicationId': 'fgijheefe',
                    'jobId': 'hcbgbhfch',
                    'evaluatedCount': 1511161572,
                    'totalQuestions': 81899341,
                    'averageFactualAccuracy': 2047822338.162079,
                    'averageCompleteness': 1877648720.136150,
                    'averageRelevance': 522978382.136536,
                    'averageCoherence': 1826408060.50977,
                    'averageScore': 1548228442.72846,
                    'passStatus': 'bahifjfga',
                    'summaryResult': 'baebfehjaf',
                    'knowledgeLevel': 'bjchdacjfa',
                },
                'update': {
                    'interviewId': 'bdiefcdfhg',
                    'candidateId': 'cheifeghd',
                    'applicationId': 'fgijheefe',
                    'jobId': 'hcbgbhfch',
                    'evaluatedCount': 1511161572,
                    'totalQuestions': 81899341,
                    'averageFactualAccuracy': 2047822338.162079,
                    'averageCompleteness': 1877648720.136150,
                    'averageRelevance': 522978382.136536,
                    'averageCoherence': 1826408060.50977,
                    'averageScore': 1548228442.72846,
                    'passStatus': 'bahifjfga',
                    'summaryResult': 'baebfehjaf',
                    'knowledgeLevel': 'bjchdacjfa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InterviewResultUpdateManyMutationInput,
        where: types.InterviewResultWhereInput,
    ) -> int:
        """Update multiple InterviewResult records

        Parameters
        ----------
        data
            InterviewResult data to update the selected InterviewResult records to
        where
            Filter to select the InterviewResult records to update

        Returns
        -------
        int
            The total number of InterviewResult records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all InterviewResult records
        total = await InterviewResult.prisma().update_many(
            data={
                'evaluatedCount': 265945728
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewResultWhereInput] = None,
        cursor: Optional[types.InterviewResultWhereUniqueInput] = None,
    ) -> int:
        """Count the number of InterviewResult records present in the database

        Parameters
        ----------
        select
            Select the InterviewResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InterviewResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InterviewResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InterviewResult.prisma().count()

        # results: prisma.types.InterviewResultCountAggregateOutput
        results = await InterviewResult.prisma().count(
            select={
                '_all': True,
                'totalQuestions': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InterviewResultCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewResultWhereInput] = None,
        cursor: Optional[types.InterviewResultWhereUniqueInput] = None,
    ) -> types.InterviewResultCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InterviewResultCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InterviewResultWhereInput] = None,
        cursor: Optional[types.InterviewResultWhereUniqueInput] = None,
    ) -> Union[int, types.InterviewResultCountAggregateOutput]:
        """Count the number of InterviewResult records present in the database

        Parameters
        ----------
        select
            Select the InterviewResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InterviewResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InterviewResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InterviewResult.prisma().count()

        # results: prisma.types.InterviewResultCountAggregateOutput
        results = await InterviewResult.prisma().count(
            select={
                '_all': True,
                'averageFactualAccuracy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InterviewResultCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InterviewResultWhereInput] = None
    ) -> int:
        """Delete multiple InterviewResult records.

        Parameters
        ----------
        where
            Optional InterviewResult filter to find the records to be deleted

        Returns
        -------
        int
            The total number of InterviewResult records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all InterviewResult records
        total = await InterviewResult.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InterviewResultScalarFieldKeys'],
        *,
        where: Optional['types.InterviewResultWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InterviewResultAvgAggregateInput'] = None,
        sum: Optional['types.InterviewResultSumAggregateInput'] = None,
        min: Optional['types.InterviewResultMinAggregateInput'] = None,
        max: Optional['types.InterviewResultMaxAggregateInput'] = None,
        having: Optional['types.InterviewResultScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InterviewResultCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InterviewResultScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InterviewResultScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InterviewResultGroupByOutput']:
        """Group InterviewResult records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar InterviewResult fields to group records by
        where
            InterviewResult filter to select records
        take
            Limit the maximum number of InterviewResult records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InterviewResultGroupByOutput]
            A list of dictionaries representing the InterviewResult record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group InterviewResult records by averageCompleteness values
        # and count how many records are in each group
        results = await InterviewResult.prisma().group_by(
            ['averageCompleteness'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChatHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChatHistory.prisma().query_raw(
            'SELECT * FROM ChatHistory WHERE id = $1',
            'egcidbiab',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChatHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChatHistory.prisma().query_first(
            'SELECT * FROM ChatHistory WHERE interviewId = $1',
            'cehjjfgeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatHistoryCreateInput,
        include: Optional[types.ChatHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChatHistory record.

        Parameters
        ----------
        data
            ChatHistory record data
        include
            Specifies which relations should be loaded on the returned ChatHistory model

        Returns
        -------
        prisma.models.ChatHistory
            The created ChatHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChatHistory record from just the required fields
        chathistory = await ChatHistory.prisma().create(
            data={
                # data to create a ChatHistory record
                'interviewId': 'hiaaaeeeh',
                'question': 'ediajdeie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChatHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChatHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChatHistory.prisma().create_many(
            data=[
                {
                    # data to create a ChatHistory record
                    'interviewId': 'jdgefgafd',
                    'question': 'bhhihbfeac',
                },
                {
                    # data to create a ChatHistory record
                    'interviewId': 'bajegedfhj',
                    'question': 'bhfjihjfhg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatHistoryWhereUniqueInput,
        include: Optional[types.ChatHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChatHistory record.

        Parameters
        ----------
        where
            ChatHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChatHistory model

        Returns
        -------
        prisma.models.ChatHistory
            The deleted ChatHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chathistory = await ChatHistory.prisma().delete(
            where={
                'id': 'iicaadeeb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatHistoryWhereUniqueInput,
        include: Optional[types.ChatHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChatHistory record.

        Parameters
        ----------
        where
            ChatHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatHistory model

        Returns
        -------
        prisma.models.ChatHistory
            The found ChatHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chathistory = await ChatHistory.prisma().find_unique(
            where={
                'id': 'bigjggdhac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatHistoryWhereUniqueInput,
        include: Optional[types.ChatHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChatHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChatHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatHistory model

        Returns
        -------
        prisma.models.ChatHistory
            The found ChatHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chathistory = await ChatHistory.prisma().find_unique_or_raise(
            where={
                'id': 'bfdbbbjhad',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatHistoryWhereInput] = None,
        cursor: Optional[types.ChatHistoryWhereUniqueInput] = None,
        include: Optional[types.ChatHistoryInclude] = None,
        order: Optional[Union[types.ChatHistoryOrderByInput, List[types.ChatHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ChatHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChatHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChatHistory records returned
        skip
            Ignore the first N results
        where
            ChatHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatHistory model
        order
            Order the returned ChatHistory records by any field
        distinct
            Filter ChatHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChatHistory]
            The list of all ChatHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChatHistory records
        chathistorys = await ChatHistory.prisma().find_many(take=10)

        # find the first 5 ChatHistory records ordered by the candidateId field
        chathistorys = await ChatHistory.prisma().find_many(
            take=5,
            order={
                'candidateId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatHistoryWhereInput] = None,
        cursor: Optional[types.ChatHistoryWhereUniqueInput] = None,
        include: Optional[types.ChatHistoryInclude] = None,
        order: Optional[Union[types.ChatHistoryOrderByInput, List[types.ChatHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ChatHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChatHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatHistory model
        order
            Order the returned ChatHistory records by any field
        distinct
            Filter ChatHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatHistory
            The first ChatHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatHistory record ordered by the applicationId field
        chathistory = await ChatHistory.prisma().find_first(
            skip=1,
            order={
                'applicationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatHistoryWhereInput] = None,
        cursor: Optional[types.ChatHistoryWhereUniqueInput] = None,
        include: Optional[types.ChatHistoryInclude] = None,
        order: Optional[Union[types.ChatHistoryOrderByInput, List[types.ChatHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ChatHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChatHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatHistory model
        order
            Order the returned ChatHistory records by any field
        distinct
            Filter ChatHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatHistory
            The first ChatHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatHistory record ordered by the question field
        chathistory = await ChatHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'question': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatHistoryUpdateInput,
        where: types.ChatHistoryWhereUniqueInput,
        include: Optional[types.ChatHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChatHistory record.

        Parameters
        ----------
        data
            ChatHistory record data specifying what to update
        where
            ChatHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChatHistory model

        Returns
        -------
        prisma.models.ChatHistory
            The updated ChatHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chathistory = await ChatHistory.prisma().update(
            where={
                'id': 'bdibjhdici',
            },
            data={
                # data to update the ChatHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatHistoryWhereUniqueInput,
        data: types.ChatHistoryUpsertInput,
        include: Optional[types.ChatHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChatHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChatHistory model

        Returns
        -------
        prisma.models.ChatHistory
            The created or updated ChatHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chathistory = await ChatHistory.prisma().upsert(
            where={
                'id': 'bceigehcbd',
            },
            data={
                'create': {
                    'id': 'bceigehcbd',
                    'interviewId': 'bajegedfhj',
                    'question': 'bhfjihjfhg',
                },
                'update': {
                    'interviewId': 'bajegedfhj',
                    'question': 'bhfjihjfhg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatHistoryUpdateManyMutationInput,
        where: types.ChatHistoryWhereInput,
    ) -> int:
        """Update multiple ChatHistory records

        Parameters
        ----------
        data
            ChatHistory data to update the selected ChatHistory records to
        where
            Filter to select the ChatHistory records to update

        Returns
        -------
        int
            The total number of ChatHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChatHistory records
        total = await ChatHistory.prisma().update_many(
            data={
                'answer': 'caehahihfe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatHistoryWhereInput] = None,
        cursor: Optional[types.ChatHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChatHistory records present in the database

        Parameters
        ----------
        select
            Select the ChatHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatHistory.prisma().count()

        # results: prisma.types.ChatHistoryCountAggregateOutput
        results = await ChatHistory.prisma().count(
            select={
                '_all': True,
                'score': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatHistoryWhereInput] = None,
        cursor: Optional[types.ChatHistoryWhereUniqueInput] = None,
    ) -> types.ChatHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatHistoryWhereInput] = None,
        cursor: Optional[types.ChatHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.ChatHistoryCountAggregateOutput]:
        """Count the number of ChatHistory records present in the database

        Parameters
        ----------
        select
            Select the ChatHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatHistory.prisma().count()

        # results: prisma.types.ChatHistoryCountAggregateOutput
        results = await ChatHistory.prisma().count(
            select={
                '_all': True,
                'level': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatHistoryWhereInput] = None
    ) -> int:
        """Delete multiple ChatHistory records.

        Parameters
        ----------
        where
            Optional ChatHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChatHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChatHistory records
        total = await ChatHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatHistoryScalarFieldKeys'],
        *,
        where: Optional['types.ChatHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatHistoryAvgAggregateInput'] = None,
        sum: Optional['types.ChatHistorySumAggregateInput'] = None,
        min: Optional['types.ChatHistoryMinAggregateInput'] = None,
        max: Optional['types.ChatHistoryMaxAggregateInput'] = None,
        having: Optional['types.ChatHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChatHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatHistoryGroupByOutput']:
        """Group ChatHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChatHistory fields to group records by
        where
            ChatHistory filter to select records
        take
            Limit the maximum number of ChatHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatHistoryGroupByOutput]
            A list of dictionaries representing the ChatHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChatHistory records by createdAt values
        # and count how many records are in each group
        results = await ChatHistory.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EvaluationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Evaluation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Evaluation.prisma().query_raw(
            'SELECT * FROM Evaluation WHERE id = $1',
            'jjacdhech',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Evaluation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Evaluation.prisma().query_first(
            'SELECT * FROM Evaluation WHERE interviewId = $1',
            'bbbjadabjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EvaluationCreateInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Evaluation record.

        Parameters
        ----------
        data
            Evaluation record data
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The created Evaluation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Evaluation record from just the required fields
        evaluation = await Evaluation.prisma().create(
            data={
                # data to create a Evaluation record
                'interviewId': 'hhaechedd',
                'question': 'gjjgegdic',
                'answer': 'bijbiccd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EvaluationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Evaluation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Evaluation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Evaluation.prisma().create_many(
            data=[
                {
                    # data to create a Evaluation record
                    'interviewId': 'cbaagdieci',
                    'question': 'jchifaegj',
                    'answer': 'dhhdhfebi',
                },
                {
                    # data to create a Evaluation record
                    'interviewId': 'decchddih',
                    'question': 'bbegbdehci',
                    'answer': 'bcebgbhhgb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Evaluation record.

        Parameters
        ----------
        where
            Evaluation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The deleted Evaluation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().delete(
            where={
                'id': 'ghegfaceg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Evaluation record.

        Parameters
        ----------
        where
            Evaluation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The found Evaluation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().find_unique(
            where={
                'id': 'hdeaejgah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Evaluation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Evaluation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The found Evaluation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().find_unique_or_raise(
            where={
                'id': 'ddiiihaci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
        include: Optional[types.EvaluationInclude] = None,
        order: Optional[Union[types.EvaluationOrderByInput, List[types.EvaluationOrderByInput]]] = None,
        distinct: Optional[List[types.EvaluationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Evaluation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Evaluation records returned
        skip
            Ignore the first N results
        where
            Evaluation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Evaluation model
        order
            Order the returned Evaluation records by any field
        distinct
            Filter Evaluation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Evaluation]
            The list of all Evaluation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Evaluation records
        evaluations = await Evaluation.prisma().find_many(take=10)

        # find the first 5 Evaluation records ordered by the question field
        evaluations = await Evaluation.prisma().find_many(
            take=5,
            order={
                'question': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
        include: Optional[types.EvaluationInclude] = None,
        order: Optional[Union[types.EvaluationOrderByInput, List[types.EvaluationOrderByInput]]] = None,
        distinct: Optional[List[types.EvaluationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Evaluation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Evaluation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Evaluation model
        order
            Order the returned Evaluation records by any field
        distinct
            Filter Evaluation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Evaluation
            The first Evaluation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Evaluation record ordered by the answer field
        evaluation = await Evaluation.prisma().find_first(
            skip=1,
            order={
                'answer': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
        include: Optional[types.EvaluationInclude] = None,
        order: Optional[Union[types.EvaluationOrderByInput, List[types.EvaluationOrderByInput]]] = None,
        distinct: Optional[List[types.EvaluationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Evaluation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Evaluation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Evaluation model
        order
            Order the returned Evaluation records by any field
        distinct
            Filter Evaluation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Evaluation
            The first Evaluation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Evaluation record ordered by the factualAccuracy field
        evaluation = await Evaluation.prisma().find_first_or_raise(
            skip=1,
            order={
                'factualAccuracy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EvaluationUpdateInput,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Evaluation record.

        Parameters
        ----------
        data
            Evaluation record data specifying what to update
        where
            Evaluation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The updated Evaluation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().update(
            where={
                'id': 'jdhfacdgf',
            },
            data={
                # data to update the Evaluation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EvaluationWhereUniqueInput,
        data: types.EvaluationUpsertInput,
        include: Optional[types.EvaluationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Evaluation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The created or updated Evaluation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().upsert(
            where={
                'id': 'fcbbahcbi',
            },
            data={
                'create': {
                    'id': 'fcbbahcbi',
                    'interviewId': 'decchddih',
                    'question': 'bbegbdehci',
                    'answer': 'bcebgbhhgb',
                },
                'update': {
                    'interviewId': 'decchddih',
                    'question': 'bbegbdehci',
                    'answer': 'bcebgbhhgb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EvaluationUpdateManyMutationInput,
        where: types.EvaluationWhereInput,
    ) -> int:
        """Update multiple Evaluation records

        Parameters
        ----------
        data
            Evaluation data to update the selected Evaluation records to
        where
            Filter to select the Evaluation records to update

        Returns
        -------
        int
            The total number of Evaluation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Evaluation records
        total = await Evaluation.prisma().update_many(
            data={
                'factualAccuracyExplanation': 'edcgchech'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Evaluation records present in the database

        Parameters
        ----------
        select
            Select the Evaluation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Evaluation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EvaluationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Evaluation.prisma().count()

        # results: prisma.types.EvaluationCountAggregateOutput
        results = await Evaluation.prisma().count(
            select={
                '_all': True,
                'completeness': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EvaluationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
    ) -> types.EvaluationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EvaluationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
    ) -> Union[int, types.EvaluationCountAggregateOutput]:
        """Count the number of Evaluation records present in the database

        Parameters
        ----------
        select
            Select the Evaluation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Evaluation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EvaluationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Evaluation.prisma().count()

        # results: prisma.types.EvaluationCountAggregateOutput
        results = await Evaluation.prisma().count(
            select={
                '_all': True,
                'completenessExplanation': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EvaluationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EvaluationWhereInput] = None
    ) -> int:
        """Delete multiple Evaluation records.

        Parameters
        ----------
        where
            Optional Evaluation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Evaluation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Evaluation records
        total = await Evaluation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EvaluationScalarFieldKeys'],
        *,
        where: Optional['types.EvaluationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EvaluationAvgAggregateInput'] = None,
        sum: Optional['types.EvaluationSumAggregateInput'] = None,
        min: Optional['types.EvaluationMinAggregateInput'] = None,
        max: Optional['types.EvaluationMaxAggregateInput'] = None,
        having: Optional['types.EvaluationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EvaluationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EvaluationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EvaluationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EvaluationGroupByOutput']:
        """Group Evaluation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Evaluation fields to group records by
        where
            Evaluation filter to select records
        take
            Limit the maximum number of Evaluation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EvaluationGroupByOutput]
            A list of dictionaries representing the Evaluation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Evaluation records by relevance values
        # and count how many records are in each group
        results = await Evaluation.prisma().group_by(
            ['relevance'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models