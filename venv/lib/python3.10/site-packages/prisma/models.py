# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    googleId: _str
    name: _str
    email: _str
    avatar: Optional[_str] = None
    role: 'enums.UserRole'
    fcm_token: Optional[_str] = None
    accountType: 'enums.AccountType'
    subscriptionActive: _bool
    trialEndsAt: Optional[datetime.datetime] = None
    registered: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    candidates: Optional[List['models.Candidate']] = None
    jobs: Optional[List['models.Job']] = None
    applications: Optional[List['models.Application']] = None
    interviews: Optional[List['models.Interview']] = None
    activities: Optional[List['models.Activity']] = None
    companies: Optional[List['models.Company']] = None
    userSettings: Optional['models.UserSettings'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Activity(bases.BaseActivity):
    """Represents a Activity record"""

    id: _str
    type: _str
    title: _str
    description: _str
    userId: _str
    entityId: Optional[_str] = None
    entityType: Optional[_str] = None
    metadata: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ActivityKeys']] = None,
        exclude: Optional[Iterable['types.ActivityKeys']] = None,
        required: Optional[Iterable['types.ActivityKeys']] = None,
        optional: Optional[Iterable['types.ActivityKeys']] = None,
        relations: Optional[Mapping['types.ActivityRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ActivityKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Activity_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Activity_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Activity_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Activity_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Activity_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Activity_relational_fields:
                        raise errors.UnknownRelationalFieldError('Activity', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Activity / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Activity',
            }
        )
        _created_partial_types.add(name)


class UserSettings(bases.BaseUserSettings):
    """Represents a UserSettings record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    language: _str
    timezone: _str
    dateFormat: _str
    autoSave: _bool
    emailDailyDigest: _bool
    emailNewCandidateAlerts: _bool
    emailMarketingEmails: _bool
    emailNewApplications: _bool
    pushNewApplications: _bool
    emailInterviewReminders: _bool
    pushInterviewReminders: _bool
    emailTaskDeadlines: _bool
    pushTaskDeadlines: _bool
    emailProductUpdates: _bool
    pushProductUpdates: _bool
    emailSecurityAlerts: _bool
    pushSecurityAlerts: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserSettingsKeys']] = None,
        exclude: Optional[Iterable['types.UserSettingsKeys']] = None,
        required: Optional[Iterable['types.UserSettingsKeys']] = None,
        optional: Optional[Iterable['types.UserSettingsKeys']] = None,
        relations: Optional[Mapping['types.UserSettingsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserSettingsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserSettings_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserSettings_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserSettings_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserSettings_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserSettings_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserSettings_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserSettings', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserSettings / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserSettings',
            }
        )
        _created_partial_types.add(name)


class Company(bases.BaseCompany):
    """Represents a Company record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    name: _str
    description: Optional[_str] = None
    industry: Optional[_str] = None
    founded: Optional[_int] = None
    companySize: Optional[_str] = None
    website: Optional[_str] = None
    email: Optional[_str] = None
    phone: Optional[_str] = None
    taxId: Optional[_str] = None
    logo: Optional[_str] = None
    coverImage: Optional[_str] = None
    primaryColor: _str
    secondaryColor: _str
    careerHeadline: Optional[_str] = None
    careerDescription: Optional[_str] = None
    featuredImages: Optional['fields.Json'] = None
    socialMedia: Optional['fields.Json'] = None
    remoteWorkPolicy: Optional[_str] = None
    remoteHiringRegions: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    locations: Optional[List['models.CompanyLocation']] = None
    teamMembers: Optional[List['models.TeamMember']] = None
    subscription: Optional['models.Subscription'] = None
    paymentMethods: Optional[List['models.PaymentMethod']] = None
    billingAddress: Optional['models.BillingAddress'] = None
    invoices: Optional[List['models.Invoice']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('remoteHiringRegions', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CompanyKeys']] = None,
        exclude: Optional[Iterable['types.CompanyKeys']] = None,
        required: Optional[Iterable['types.CompanyKeys']] = None,
        optional: Optional[Iterable['types.CompanyKeys']] = None,
        relations: Optional[Mapping['types.CompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Company_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Company_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Company_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Company_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Company_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Company_relational_fields:
                        raise errors.UnknownRelationalFieldError('Company', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Company / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Company',
            }
        )
        _created_partial_types.add(name)


class CompanyLocation(bases.BaseCompanyLocation):
    """Represents a CompanyLocation record"""

    id: _str
    companyId: _str
    company: Optional['models.Company'] = None
    name: _str
    type: _str
    address: _str
    city: _str
    state: Optional[_str] = None
    country: _str
    zipCode: Optional[_str] = None
    phone: Optional[_str] = None
    email: Optional[_str] = None
    isHeadquarters: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CompanyLocationKeys']] = None,
        exclude: Optional[Iterable['types.CompanyLocationKeys']] = None,
        required: Optional[Iterable['types.CompanyLocationKeys']] = None,
        optional: Optional[Iterable['types.CompanyLocationKeys']] = None,
        relations: Optional[Mapping['types.CompanyLocationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CompanyLocationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CompanyLocation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CompanyLocation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CompanyLocation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CompanyLocation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CompanyLocation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CompanyLocation_relational_fields:
                        raise errors.UnknownRelationalFieldError('CompanyLocation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CompanyLocation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CompanyLocation',
            }
        )
        _created_partial_types.add(name)


class TeamMember(bases.BaseTeamMember):
    """Represents a TeamMember record"""

    id: _str
    companyId: _str
    company: Optional['models.Company'] = None
    name: _str
    email: _str
    role: _str
    department: _str
    phone: Optional[_str] = None
    avatar: Optional[_str] = None
    status: _str
    accessLevel: _str
    invitedAt: Optional[datetime.datetime] = None
    joinedAt: Optional[datetime.datetime] = None
    invitedBy: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TeamMemberKeys']] = None,
        exclude: Optional[Iterable['types.TeamMemberKeys']] = None,
        required: Optional[Iterable['types.TeamMemberKeys']] = None,
        optional: Optional[Iterable['types.TeamMemberKeys']] = None,
        relations: Optional[Mapping['types.TeamMemberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TeamMemberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TeamMember_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TeamMember_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TeamMember_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TeamMember_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TeamMember_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TeamMember_relational_fields:
                        raise errors.UnknownRelationalFieldError('TeamMember', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TeamMember / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TeamMember',
            }
        )
        _created_partial_types.add(name)


class Subscription(bases.BaseSubscription):
    """Represents a Subscription record"""

    id: _str
    companyId: _str
    company: Optional['models.Company'] = None
    planName: _str
    planPrice: decimal.Decimal
    billingCycle: _str
    status: _str
    currentPeriodStart: datetime.datetime
    currentPeriodEnd: datetime.datetime
    cancelAtPeriodEnd: _bool
    stripeSubscriptionId: Optional[_str] = None
    stripeCustomerId: Optional[_str] = None
    teamMemberLimit: _int
    aiCreditsLimit: _int
    storageLimit: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    addons: Optional[List['models.SubscriptionAddon']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SubscriptionKeys']] = None,
        exclude: Optional[Iterable['types.SubscriptionKeys']] = None,
        required: Optional[Iterable['types.SubscriptionKeys']] = None,
        optional: Optional[Iterable['types.SubscriptionKeys']] = None,
        relations: Optional[Mapping['types.SubscriptionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SubscriptionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Subscription_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Subscription_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Subscription_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Subscription_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Subscription_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Subscription_relational_fields:
                        raise errors.UnknownRelationalFieldError('Subscription', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Subscription / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Subscription',
            }
        )
        _created_partial_types.add(name)


class PaymentMethod(bases.BasePaymentMethod):
    """Represents a PaymentMethod record"""

    id: _str
    companyId: _str
    company: Optional['models.Company'] = None
    type: _str
    last4: _str
    brand: _str
    expiryMonth: _int
    expiryYear: _int
    isDefault: _bool
    stripePaymentMethodId: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PaymentMethodKeys']] = None,
        exclude: Optional[Iterable['types.PaymentMethodKeys']] = None,
        required: Optional[Iterable['types.PaymentMethodKeys']] = None,
        optional: Optional[Iterable['types.PaymentMethodKeys']] = None,
        relations: Optional[Mapping['types.PaymentMethodRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PaymentMethodKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PaymentMethod_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PaymentMethod_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PaymentMethod_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PaymentMethod_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PaymentMethod_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PaymentMethod_relational_fields:
                        raise errors.UnknownRelationalFieldError('PaymentMethod', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PaymentMethod / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PaymentMethod',
            }
        )
        _created_partial_types.add(name)


class BillingAddress(bases.BaseBillingAddress):
    """Represents a BillingAddress record"""

    id: _str
    companyId: _str
    company: Optional['models.Company'] = None
    contactName: _str
    contactEmail: _str
    contactPhone: Optional[_str] = None
    companyName: _str
    addressLine1: _str
    addressLine2: Optional[_str] = None
    city: _str
    state: Optional[_str] = None
    zipCode: _str
    country: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BillingAddressKeys']] = None,
        exclude: Optional[Iterable['types.BillingAddressKeys']] = None,
        required: Optional[Iterable['types.BillingAddressKeys']] = None,
        optional: Optional[Iterable['types.BillingAddressKeys']] = None,
        relations: Optional[Mapping['types.BillingAddressRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BillingAddressKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BillingAddress_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BillingAddress_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BillingAddress_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BillingAddress_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BillingAddress_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BillingAddress_relational_fields:
                        raise errors.UnknownRelationalFieldError('BillingAddress', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BillingAddress / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BillingAddress',
            }
        )
        _created_partial_types.add(name)


class Invoice(bases.BaseInvoice):
    """Represents a Invoice record"""

    id: _str
    companyId: _str
    company: Optional['models.Company'] = None
    invoiceNumber: _str
    amount: decimal.Decimal
    currency: _str
    status: _str
    dueDate: datetime.datetime
    paidAt: Optional[datetime.datetime] = None
    stripeInvoiceId: Optional[_str] = None
    downloadUrl: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InvoiceKeys']] = None,
        exclude: Optional[Iterable['types.InvoiceKeys']] = None,
        required: Optional[Iterable['types.InvoiceKeys']] = None,
        optional: Optional[Iterable['types.InvoiceKeys']] = None,
        relations: Optional[Mapping['types.InvoiceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InvoiceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Invoice_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Invoice_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Invoice_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Invoice_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Invoice_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Invoice_relational_fields:
                        raise errors.UnknownRelationalFieldError('Invoice', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Invoice / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Invoice',
            }
        )
        _created_partial_types.add(name)


class SubscriptionAddon(bases.BaseSubscriptionAddon):
    """Represents a SubscriptionAddon record"""

    id: _str
    subscriptionId: _str
    subscription: Optional['models.Subscription'] = None
    name: _str
    description: Optional[_str] = None
    price: decimal.Decimal
    billingCycle: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SubscriptionAddonKeys']] = None,
        exclude: Optional[Iterable['types.SubscriptionAddonKeys']] = None,
        required: Optional[Iterable['types.SubscriptionAddonKeys']] = None,
        optional: Optional[Iterable['types.SubscriptionAddonKeys']] = None,
        relations: Optional[Mapping['types.SubscriptionAddonRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SubscriptionAddonKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SubscriptionAddon_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SubscriptionAddon_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SubscriptionAddon_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SubscriptionAddon_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _SubscriptionAddon_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _SubscriptionAddon_relational_fields:
                        raise errors.UnknownRelationalFieldError('SubscriptionAddon', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SubscriptionAddon / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SubscriptionAddon',
            }
        )
        _created_partial_types.add(name)


class JobSession(bases.BaseJobSession):
    """Represents a JobSession record"""

    id: _str
    sessionId: _str
    step: _int
    basicInfo: Optional['fields.Json'] = None
    jobDetails: Optional['fields.Json'] = None
    requirements: Optional['fields.Json'] = None
    publishOptions: Optional['fields.Json'] = None
    expiresAt: datetime.datetime
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.JobSessionKeys']] = None,
        exclude: Optional[Iterable['types.JobSessionKeys']] = None,
        required: Optional[Iterable['types.JobSessionKeys']] = None,
        optional: Optional[Iterable['types.JobSessionKeys']] = None,
        relations: Optional[Mapping['types.JobSessionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.JobSessionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _JobSession_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _JobSession_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _JobSession_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _JobSession_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "JobSession" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid JobSession / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'JobSession',
            }
        )
        _created_partial_types.add(name)


class Job(bases.BaseJob):
    """Represents a Job record"""

    id: _str
    title: _str
    department: _str
    location: _str
    employmentType: 'enums.EmploymentType'
    salaryMin: _int
    salaryMax: _int
    salaryPeriod: 'enums.SalaryPeriod'
    description: _str
    responsibilities: List[_str]
    requirements: List[_str]
    experience: Optional[_str] = None
    teamSize: Optional[_str] = None
    reportingStructure: Optional[_str] = None
    skills: List[_str]
    education: Optional[_str] = None
    certifications: List[_str]
    languages: 'fields.Json'
    softSkills: List[_str]
    isRemote: _bool
    isHybrid: _bool
    internalJobBoard: _bool
    externalJobBoards: _bool
    socialMedia: _bool
    applicationFormFields: Optional['fields.Json'] = None
    status: 'enums.JobStatus'
    publishedAt: Optional[datetime.datetime] = None
    closedAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    userId: _str
    user: Optional['models.User'] = None
    applications: Optional[List['models.Application']] = None
    interviews: Optional[List['models.Interview']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('responsibilities', 'requirements', 'skills', 'certifications', 'softSkills', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.JobKeys']] = None,
        exclude: Optional[Iterable['types.JobKeys']] = None,
        required: Optional[Iterable['types.JobKeys']] = None,
        optional: Optional[Iterable['types.JobKeys']] = None,
        relations: Optional[Mapping['types.JobRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.JobKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Job_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Job_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Job_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Job_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Job_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Job_relational_fields:
                        raise errors.UnknownRelationalFieldError('Job', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Job / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Job',
            }
        )
        _created_partial_types.add(name)


class Candidate(bases.BaseCandidate):
    """Represents a Candidate record"""

    id: _str
    email: _str
    name: _str
    phone: Optional[_str] = None
    address: List[_str]
    location: Optional[_str] = None
    personalInfo: Optional['fields.Json'] = None
    summary: Optional[_str] = None
    education: Optional['fields.Json'] = None
    experience: Optional['fields.Json'] = None
    previousJobs: Optional['fields.Json'] = None
    internships: List[_str]
    technicalSkills: List[_str]
    softSkills: List[_str]
    languages: Optional['fields.Json'] = None
    certifications: Optional['fields.Json'] = None
    projects: Optional['fields.Json'] = None
    hobbies: List[_str]
    salaryExpectation: Optional[_int] = None
    department: Optional[_str] = None
    applicationStatus: 'enums.ApplicationStatus'
    interviewStatus: 'enums.InterviewStatus'
    resume: Optional[_str] = None
    portfolio: Optional[_str] = None
    linkedin: Optional[_str] = None
    github: Optional[_str] = None
    userId: Optional[_str] = None
    user: Optional['models.User'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    applications: Optional[List['models.Application']] = None
    interviews: Optional[List['models.Interview']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('address', 'internships', 'technicalSkills', 'softSkills', 'hobbies', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CandidateKeys']] = None,
        exclude: Optional[Iterable['types.CandidateKeys']] = None,
        required: Optional[Iterable['types.CandidateKeys']] = None,
        optional: Optional[Iterable['types.CandidateKeys']] = None,
        relations: Optional[Mapping['types.CandidateRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CandidateKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Candidate_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Candidate_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Candidate_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Candidate_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Candidate_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Candidate_relational_fields:
                        raise errors.UnknownRelationalFieldError('Candidate', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Candidate / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Candidate',
            }
        )
        _created_partial_types.add(name)


class Application(bases.BaseApplication):
    """Represents a Application record"""

    id: _str
    jobId: _str
    candidateId: _str
    coverLetter: Optional[_str] = None
    status: 'enums.ApplicationStatus'
    matchScore: Optional[_int] = None
    notes: Optional[_str] = None
    joinToken: Optional[_str] = None
    tokenExpiry: Optional[datetime.datetime] = None
    appliedAt: datetime.datetime
    updatedAt: datetime.datetime
    job: Optional['models.Job'] = None
    candidate: Optional['models.Candidate'] = None
    user: Optional['models.User'] = None
    userId: _str
    interviews: Optional[List['models.Interview']] = None
    interviewResult: Optional['models.InterviewResult'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ApplicationKeys']] = None,
        exclude: Optional[Iterable['types.ApplicationKeys']] = None,
        required: Optional[Iterable['types.ApplicationKeys']] = None,
        optional: Optional[Iterable['types.ApplicationKeys']] = None,
        relations: Optional[Mapping['types.ApplicationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ApplicationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Application_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Application_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Application_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Application_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Application_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Application_relational_fields:
                        raise errors.UnknownRelationalFieldError('Application', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Application / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Application',
            }
        )
        _created_partial_types.add(name)


class Interview(bases.BaseInterview):
    """Represents a Interview record"""

    id: _str
    candidateId: _str
    applicationId: _str
    scheduledById: _str
    jobId: _str
    type: 'enums.InterviewType'
    status: 'enums.InterviewStatus'
    scheduledAt: datetime.datetime
    duration: _int
    timezone: _str
    meetingLink: Optional[_str] = None
    location: Optional[_str] = None
    notes: Optional[_str] = None
    interviewers: Optional['fields.Json'] = None
    feedback: Optional['fields.Json'] = None
    rating: Optional[_int] = None
    recommendation: Optional[_str] = None
    joinToken: Optional[_str] = None
    tokenExpiry: Optional[datetime.datetime] = None
    invitationSent: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    startedAt: Optional[datetime.datetime] = None
    completedAt: Optional[datetime.datetime] = None
    candidate: Optional['models.Candidate'] = None
    application: Optional['models.Application'] = None
    scheduledBy: Optional['models.User'] = None
    job: Optional['models.Job'] = None
    interviewResult: Optional['models.InterviewResult'] = None
    chatHistory: Optional[List['models.ChatHistory']] = None
    evaluations: Optional[List['models.Evaluation']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InterviewKeys']] = None,
        exclude: Optional[Iterable['types.InterviewKeys']] = None,
        required: Optional[Iterable['types.InterviewKeys']] = None,
        optional: Optional[Iterable['types.InterviewKeys']] = None,
        relations: Optional[Mapping['types.InterviewRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InterviewKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Interview_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Interview_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Interview_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Interview_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Interview_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Interview_relational_fields:
                        raise errors.UnknownRelationalFieldError('Interview', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Interview / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Interview',
            }
        )
        _created_partial_types.add(name)


class InterviewResult(bases.BaseInterviewResult):
    """Represents a InterviewResult record"""

    id: _str
    interviewId: _str
    candidateId: _str
    applicationId: _str
    jobId: _str
    evaluatedCount: _int
    totalQuestions: _int
    averageFactualAccuracy: _float
    averageCompleteness: _float
    averageRelevance: _float
    averageCoherence: _float
    averageScore: _float
    passStatus: _str
    summaryResult: _str
    knowledgeLevel: _str
    recommendations: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    interview: Optional['models.Interview'] = None
    application: Optional['models.Application'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InterviewResultKeys']] = None,
        exclude: Optional[Iterable['types.InterviewResultKeys']] = None,
        required: Optional[Iterable['types.InterviewResultKeys']] = None,
        optional: Optional[Iterable['types.InterviewResultKeys']] = None,
        relations: Optional[Mapping['types.InterviewResultRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InterviewResultKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _InterviewResult_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _InterviewResult_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _InterviewResult_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _InterviewResult_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _InterviewResult_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _InterviewResult_relational_fields:
                        raise errors.UnknownRelationalFieldError('InterviewResult', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid InterviewResult / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'InterviewResult',
            }
        )
        _created_partial_types.add(name)


class ChatHistory(bases.BaseChatHistory):
    """Represents a ChatHistory record"""

    id: _str
    interviewId: _str
    candidateId: Optional[_str] = None
    applicationId: Optional[_str] = None
    question: _str
    answer: Optional[_str] = None
    score: Optional[_int] = None
    level: _int
    createdAt: datetime.datetime
    interview: Optional['models.Interview'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ChatHistoryKeys']] = None,
        exclude: Optional[Iterable['types.ChatHistoryKeys']] = None,
        required: Optional[Iterable['types.ChatHistoryKeys']] = None,
        optional: Optional[Iterable['types.ChatHistoryKeys']] = None,
        relations: Optional[Mapping['types.ChatHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ChatHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ChatHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ChatHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ChatHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ChatHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ChatHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ChatHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('ChatHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ChatHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ChatHistory',
            }
        )
        _created_partial_types.add(name)


class Evaluation(bases.BaseEvaluation):
    """Represents a Evaluation record"""

    id: _str
    interviewId: _str
    question: _str
    answer: _str
    factualAccuracy: Optional[_str] = None
    factualAccuracyExplanation: Optional[_str] = None
    completeness: Optional[_str] = None
    completenessExplanation: Optional[_str] = None
    relevance: Optional[_str] = None
    relevanceExplanation: Optional[_str] = None
    coherence: Optional[_str] = None
    coherenceExplanation: Optional[_str] = None
    score: Optional[_float] = None
    inputTokens: Optional[_int] = None
    outputTokens: Optional[_int] = None
    finalEvaluation: Optional[_str] = None
    evaluatedAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    interview: Optional['models.Interview'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EvaluationKeys']] = None,
        exclude: Optional[Iterable['types.EvaluationKeys']] = None,
        required: Optional[Iterable['types.EvaluationKeys']] = None,
        optional: Optional[Iterable['types.EvaluationKeys']] = None,
        relations: Optional[Mapping['types.EvaluationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EvaluationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Evaluation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Evaluation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Evaluation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Evaluation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Evaluation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Evaluation_relational_fields:
                        raise errors.UnknownRelationalFieldError('Evaluation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Evaluation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Evaluation',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'candidates',
        'jobs',
        'applications',
        'interviews',
        'activities',
        'companies',
        'userSettings',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('googleId', {
            'name': 'googleId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('avatar', {
            'name': 'avatar',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('fcm_token', {
            'name': 'fcm_token',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accountType', {
            'name': 'accountType',
            'is_list': False,
            'optional': False,
            'type': 'enums.AccountType',
            'is_relational': False,
            'documentation': None,
        }),
        ('subscriptionActive', {
            'name': 'subscriptionActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('trialEndsAt', {
            'name': 'trialEndsAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('registered', {
            'name': 'registered',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('candidates', {
            'name': 'candidates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Candidate\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('jobs', {
            'name': 'jobs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Job\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('applications', {
            'name': 'applications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Application\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('interviews', {
            'name': 'interviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Interview\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('activities', {
            'name': 'activities',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Activity\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('companies', {
            'name': 'companies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Company\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userSettings', {
            'name': 'userSettings',
            'is_list': False,
            'optional': True,
            'type': 'models.UserSettings',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Activity_relational_fields: Set[str] = {
        'user',
    }
_Activity_fields: Dict['types.ActivityKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('entityId', {
            'name': 'entityId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('entityType', {
            'name': 'entityType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserSettings_relational_fields: Set[str] = {
        'user',
    }
_UserSettings_fields: Dict['types.UserSettingsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('language', {
            'name': 'language',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('timezone', {
            'name': 'timezone',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateFormat', {
            'name': 'dateFormat',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('autoSave', {
            'name': 'autoSave',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailDailyDigest', {
            'name': 'emailDailyDigest',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailNewCandidateAlerts', {
            'name': 'emailNewCandidateAlerts',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailMarketingEmails', {
            'name': 'emailMarketingEmails',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailNewApplications', {
            'name': 'emailNewApplications',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pushNewApplications', {
            'name': 'pushNewApplications',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailInterviewReminders', {
            'name': 'emailInterviewReminders',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pushInterviewReminders', {
            'name': 'pushInterviewReminders',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailTaskDeadlines', {
            'name': 'emailTaskDeadlines',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pushTaskDeadlines', {
            'name': 'pushTaskDeadlines',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailProductUpdates', {
            'name': 'emailProductUpdates',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pushProductUpdates', {
            'name': 'pushProductUpdates',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailSecurityAlerts', {
            'name': 'emailSecurityAlerts',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pushSecurityAlerts', {
            'name': 'pushSecurityAlerts',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Company_relational_fields: Set[str] = {
        'user',
        'locations',
        'teamMembers',
        'subscription',
        'paymentMethods',
        'billingAddress',
        'invoices',
    }
_Company_fields: Dict['types.CompanyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('industry', {
            'name': 'industry',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('founded', {
            'name': 'founded',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('companySize', {
            'name': 'companySize',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('website', {
            'name': 'website',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('taxId', {
            'name': 'taxId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('logo', {
            'name': 'logo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coverImage', {
            'name': 'coverImage',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('primaryColor', {
            'name': 'primaryColor',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('secondaryColor', {
            'name': 'secondaryColor',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('careerHeadline', {
            'name': 'careerHeadline',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('careerDescription', {
            'name': 'careerDescription',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('featuredImages', {
            'name': 'featuredImages',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('socialMedia', {
            'name': 'socialMedia',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('remoteWorkPolicy', {
            'name': 'remoteWorkPolicy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('remoteHiringRegions', {
            'name': 'remoteHiringRegions',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('locations', {
            'name': 'locations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CompanyLocation\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('teamMembers', {
            'name': 'teamMembers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('subscription', {
            'name': 'subscription',
            'is_list': False,
            'optional': True,
            'type': 'models.Subscription',
            'is_relational': True,
            'documentation': None,
        }),
        ('paymentMethods', {
            'name': 'paymentMethods',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PaymentMethod\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('billingAddress', {
            'name': 'billingAddress',
            'is_list': False,
            'optional': True,
            'type': 'models.BillingAddress',
            'is_relational': True,
            'documentation': None,
        }),
        ('invoices', {
            'name': 'invoices',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Invoice\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_CompanyLocation_relational_fields: Set[str] = {
        'company',
    }
_CompanyLocation_fields: Dict['types.CompanyLocationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('city', {
            'name': 'city',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('state', {
            'name': 'state',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('zipCode', {
            'name': 'zipCode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isHeadquarters', {
            'name': 'isHeadquarters',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_TeamMember_relational_fields: Set[str] = {
        'company',
    }
_TeamMember_fields: Dict['types.TeamMemberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('avatar', {
            'name': 'avatar',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accessLevel', {
            'name': 'accessLevel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('invitedAt', {
            'name': 'invitedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('joinedAt', {
            'name': 'joinedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('invitedBy', {
            'name': 'invitedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Subscription_relational_fields: Set[str] = {
        'company',
        'addons',
    }
_Subscription_fields: Dict['types.SubscriptionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('planName', {
            'name': 'planName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('planPrice', {
            'name': 'planPrice',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('billingCycle', {
            'name': 'billingCycle',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('currentPeriodStart', {
            'name': 'currentPeriodStart',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('currentPeriodEnd', {
            'name': 'currentPeriodEnd',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('cancelAtPeriodEnd', {
            'name': 'cancelAtPeriodEnd',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripeSubscriptionId', {
            'name': 'stripeSubscriptionId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripeCustomerId', {
            'name': 'stripeCustomerId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamMemberLimit', {
            'name': 'teamMemberLimit',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('aiCreditsLimit', {
            'name': 'aiCreditsLimit',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('storageLimit', {
            'name': 'storageLimit',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('addons', {
            'name': 'addons',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SubscriptionAddon\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PaymentMethod_relational_fields: Set[str] = {
        'company',
    }
_PaymentMethod_fields: Dict['types.PaymentMethodKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last4', {
            'name': 'last4',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('brand', {
            'name': 'brand',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiryMonth', {
            'name': 'expiryMonth',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiryYear', {
            'name': 'expiryYear',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isDefault', {
            'name': 'isDefault',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripePaymentMethodId', {
            'name': 'stripePaymentMethodId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_BillingAddress_relational_fields: Set[str] = {
        'company',
    }
_BillingAddress_fields: Dict['types.BillingAddressKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('contactName', {
            'name': 'contactName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contactEmail', {
            'name': 'contactEmail',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contactPhone', {
            'name': 'contactPhone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyName', {
            'name': 'companyName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('addressLine1', {
            'name': 'addressLine1',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('addressLine2', {
            'name': 'addressLine2',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('city', {
            'name': 'city',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('state', {
            'name': 'state',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('zipCode', {
            'name': 'zipCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Invoice_relational_fields: Set[str] = {
        'company',
    }
_Invoice_fields: Dict['types.InvoiceKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('invoiceNumber', {
            'name': 'invoiceNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dueDate', {
            'name': 'dueDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('paidAt', {
            'name': 'paidAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripeInvoiceId', {
            'name': 'stripeInvoiceId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('downloadUrl', {
            'name': 'downloadUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_SubscriptionAddon_relational_fields: Set[str] = {
        'subscription',
    }
_SubscriptionAddon_fields: Dict['types.SubscriptionAddonKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subscriptionId', {
            'name': 'subscriptionId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subscription', {
            'name': 'subscription',
            'is_list': False,
            'optional': True,
            'type': 'models.Subscription',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('billingCycle', {
            'name': 'billingCycle',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_JobSession_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_JobSession_fields: Dict['types.JobSessionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sessionId', {
            'name': 'sessionId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('step', {
            'name': 'step',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('basicInfo', {
            'name': 'basicInfo',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobDetails', {
            'name': 'jobDetails',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('requirements', {
            'name': 'requirements',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('publishOptions', {
            'name': 'publishOptions',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Job_relational_fields: Set[str] = {
        'user',
        'applications',
        'interviews',
    }
_Job_fields: Dict['types.JobKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employmentType', {
            'name': 'employmentType',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmploymentType',
            'is_relational': False,
            'documentation': None,
        }),
        ('salaryMin', {
            'name': 'salaryMin',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('salaryMax', {
            'name': 'salaryMax',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('salaryPeriod', {
            'name': 'salaryPeriod',
            'is_list': False,
            'optional': False,
            'type': 'enums.SalaryPeriod',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('responsibilities', {
            'name': 'responsibilities',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('requirements', {
            'name': 'requirements',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('experience', {
            'name': 'experience',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamSize', {
            'name': 'teamSize',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reportingStructure', {
            'name': 'reportingStructure',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('education', {
            'name': 'education',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('certifications', {
            'name': 'certifications',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('languages', {
            'name': 'languages',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('softSkills', {
            'name': 'softSkills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('isRemote', {
            'name': 'isRemote',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isHybrid', {
            'name': 'isHybrid',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('internalJobBoard', {
            'name': 'internalJobBoard',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('externalJobBoards', {
            'name': 'externalJobBoards',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('socialMedia', {
            'name': 'socialMedia',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('applicationFormFields', {
            'name': 'applicationFormFields',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.JobStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('publishedAt', {
            'name': 'publishedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('closedAt', {
            'name': 'closedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('applications', {
            'name': 'applications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Application\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('interviews', {
            'name': 'interviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Interview\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Candidate_relational_fields: Set[str] = {
        'user',
        'applications',
        'interviews',
    }
_Candidate_fields: Dict['types.CandidateKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('personalInfo', {
            'name': 'personalInfo',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('summary', {
            'name': 'summary',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('education', {
            'name': 'education',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('experience', {
            'name': 'experience',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('previousJobs', {
            'name': 'previousJobs',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('internships', {
            'name': 'internships',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('technicalSkills', {
            'name': 'technicalSkills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('softSkills', {
            'name': 'softSkills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('languages', {
            'name': 'languages',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('certifications', {
            'name': 'certifications',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('projects', {
            'name': 'projects',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('hobbies', {
            'name': 'hobbies',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('salaryExpectation', {
            'name': 'salaryExpectation',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('applicationStatus', {
            'name': 'applicationStatus',
            'is_list': False,
            'optional': False,
            'type': 'enums.ApplicationStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('interviewStatus', {
            'name': 'interviewStatus',
            'is_list': False,
            'optional': False,
            'type': 'enums.InterviewStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('resume', {
            'name': 'resume',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('portfolio', {
            'name': 'portfolio',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('linkedin', {
            'name': 'linkedin',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('github', {
            'name': 'github',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('applications', {
            'name': 'applications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Application\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('interviews', {
            'name': 'interviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Interview\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Application_relational_fields: Set[str] = {
        'job',
        'candidate',
        'user',
        'interviews',
        'interviewResult',
    }
_Application_fields: Dict['types.ApplicationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobId', {
            'name': 'jobId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('candidateId', {
            'name': 'candidateId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coverLetter', {
            'name': 'coverLetter',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ApplicationStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('matchScore', {
            'name': 'matchScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('joinToken', {
            'name': 'joinToken',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokenExpiry', {
            'name': 'tokenExpiry',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('appliedAt', {
            'name': 'appliedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.Job',
            'is_relational': True,
            'documentation': None,
        }),
        ('candidate', {
            'name': 'candidate',
            'is_list': False,
            'optional': True,
            'type': 'models.Candidate',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('interviews', {
            'name': 'interviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Interview\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('interviewResult', {
            'name': 'interviewResult',
            'is_list': False,
            'optional': True,
            'type': 'models.InterviewResult',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Interview_relational_fields: Set[str] = {
        'candidate',
        'application',
        'scheduledBy',
        'job',
        'interviewResult',
        'chatHistory',
        'evaluations',
    }
_Interview_fields: Dict['types.InterviewKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('candidateId', {
            'name': 'candidateId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('applicationId', {
            'name': 'applicationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledById', {
            'name': 'scheduledById',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobId', {
            'name': 'jobId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.InterviewType',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.InterviewStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledAt', {
            'name': 'scheduledAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration', {
            'name': 'duration',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('timezone', {
            'name': 'timezone',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('meetingLink', {
            'name': 'meetingLink',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('interviewers', {
            'name': 'interviewers',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('feedback', {
            'name': 'feedback',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('recommendation', {
            'name': 'recommendation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('joinToken', {
            'name': 'joinToken',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokenExpiry', {
            'name': 'tokenExpiry',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('invitationSent', {
            'name': 'invitationSent',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('startedAt', {
            'name': 'startedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('candidate', {
            'name': 'candidate',
            'is_list': False,
            'optional': True,
            'type': 'models.Candidate',
            'is_relational': True,
            'documentation': None,
        }),
        ('application', {
            'name': 'application',
            'is_list': False,
            'optional': True,
            'type': 'models.Application',
            'is_relational': True,
            'documentation': None,
        }),
        ('scheduledBy', {
            'name': 'scheduledBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.Job',
            'is_relational': True,
            'documentation': None,
        }),
        ('interviewResult', {
            'name': 'interviewResult',
            'is_list': False,
            'optional': True,
            'type': 'models.InterviewResult',
            'is_relational': True,
            'documentation': None,
        }),
        ('chatHistory', {
            'name': 'chatHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ChatHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('evaluations', {
            'name': 'evaluations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Evaluation\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_InterviewResult_relational_fields: Set[str] = {
        'interview',
        'application',
    }
_InterviewResult_fields: Dict['types.InterviewResultKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('interviewId', {
            'name': 'interviewId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('candidateId', {
            'name': 'candidateId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('applicationId', {
            'name': 'applicationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobId', {
            'name': 'jobId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('evaluatedCount', {
            'name': 'evaluatedCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalQuestions', {
            'name': 'totalQuestions',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('averageFactualAccuracy', {
            'name': 'averageFactualAccuracy',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('averageCompleteness', {
            'name': 'averageCompleteness',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('averageRelevance', {
            'name': 'averageRelevance',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('averageCoherence', {
            'name': 'averageCoherence',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('averageScore', {
            'name': 'averageScore',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('passStatus', {
            'name': 'passStatus',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('summaryResult', {
            'name': 'summaryResult',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('knowledgeLevel', {
            'name': 'knowledgeLevel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('recommendations', {
            'name': 'recommendations',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('interview', {
            'name': 'interview',
            'is_list': False,
            'optional': True,
            'type': 'models.Interview',
            'is_relational': True,
            'documentation': None,
        }),
        ('application', {
            'name': 'application',
            'is_list': False,
            'optional': True,
            'type': 'models.Application',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ChatHistory_relational_fields: Set[str] = {
        'interview',
    }
_ChatHistory_fields: Dict['types.ChatHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('interviewId', {
            'name': 'interviewId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('candidateId', {
            'name': 'candidateId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('applicationId', {
            'name': 'applicationId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('question', {
            'name': 'question',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('answer', {
            'name': 'answer',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('score', {
            'name': 'score',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('level', {
            'name': 'level',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('interview', {
            'name': 'interview',
            'is_list': False,
            'optional': True,
            'type': 'models.Interview',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Evaluation_relational_fields: Set[str] = {
        'interview',
    }
_Evaluation_fields: Dict['types.EvaluationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('interviewId', {
            'name': 'interviewId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('question', {
            'name': 'question',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('answer', {
            'name': 'answer',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('factualAccuracy', {
            'name': 'factualAccuracy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('factualAccuracyExplanation', {
            'name': 'factualAccuracyExplanation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('completeness', {
            'name': 'completeness',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('completenessExplanation', {
            'name': 'completenessExplanation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('relevance', {
            'name': 'relevance',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('relevanceExplanation', {
            'name': 'relevanceExplanation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coherence', {
            'name': 'coherence',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coherenceExplanation', {
            'name': 'coherenceExplanation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('score', {
            'name': 'score',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('inputTokens', {
            'name': 'inputTokens',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('outputTokens', {
            'name': 'outputTokens',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('finalEvaluation', {
            'name': 'finalEvaluation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('evaluatedAt', {
            'name': 'evaluatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('interview', {
            'name': 'interview',
            'is_list': False,
            'optional': True,
            'type': 'models.Interview',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Activity)
model_rebuild(UserSettings)
model_rebuild(Company)
model_rebuild(CompanyLocation)
model_rebuild(TeamMember)
model_rebuild(Subscription)
model_rebuild(PaymentMethod)
model_rebuild(BillingAddress)
model_rebuild(Invoice)
model_rebuild(SubscriptionAddon)
model_rebuild(JobSession)
model_rebuild(Job)
model_rebuild(Candidate)
model_rebuild(Application)
model_rebuild(Interview)
model_rebuild(InterviewResult)
model_rebuild(ChatHistory)
model_rebuild(Evaluation)
